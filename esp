local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Загружаем оригинальную библиотеку ESP
local esp = loadstring(game:HttpGet('https://raw.githubusercontent.com/ZXCdswqezxc/libtests/refs/heads/main/es'))()

-- Инициализируем настройки ESP
esp.enabled = false         -- ESP выключен по умолчанию
esp.teamcheck = false       -- Проверка команды выключена
esp.visiblecheck = false    -- Проверка видимости выключена
esp.outlines = true         -- Обводка включена
esp.limitdistance = false   -- Ограничение дистанции выключено
esp.maxdistance = 5000      -- Максимальная дистанция (если включено)

-- Настройки трейсеров
esp.tracers = false         -- Трейсеры выключены по умолчанию
esp.tracer_color = Color3.fromRGB(255, 255, 255)  -- Цвет трейсеров (белый)
esp.tracer_origin = "Bottom" -- Место начала трейсеров (Bottom, Top, Center, Mouse)
esp.tracer_thickness = 1    -- Толщина трейсеров

-- Настройка боксов
esp.team_boxes[1] = false                       -- Выключены по умолчанию
esp.team_boxes[2] = Color3.fromRGB(255, 255, 255)   -- Белый цвет
esp.team_boxes[3] = Color3.fromRGB(255, 255, 255)   -- Цвет заливки
esp.team_boxes[4] = 0.2                         -- Прозрачность заливки

-- Настройка полосок здоровья
esp.team_healthbar[1] = false                   -- Выключены по умолчанию
esp.team_healthbar[2] = Color3.fromRGB(255, 255, 255)  -- Цвет полного здоровья (белый)
esp.team_healthbar[3] = Color3.fromRGB(255, 255, 255)  -- Цвет низкого здоровья (белый)
esp.healthbar_thickness = 1                     -- Толщина полоски здоровья в пикселях

-- Настройка текстовых элементов
esp.team_names[1] = false                       -- Имена игроков выключены
esp.team_names[2] = Color3.fromRGB(255, 255, 255) -- Белый цвет для имен
esp.team_health = false                         -- Числовые значения здоровья ВСЕГДА выключены
esp.team_distance = false                       -- Отображение дистанции выключено
esp.team_weapon[1] = false                      -- Отображение оружия ВСЕГДА выключено (убираем из интерфейса)
esp.font = 'Plex'                               -- Шрифт по умолчанию
esp.textsize = 13                               -- Размер текста

-- Настройка фиксированных размеров
esp.fixed_size_enabled = true      -- Включаем фиксированные размеры по умолчанию
esp.fixed_box_width = 4           -- Ширина бокса
esp.fixed_box_height = 6          -- Высота бокса

-- Деактивируем настройки врагов, так как они не используются
esp.enemy_boxes[1] = false

-- Переменная для отслеживания положения мыши
local mousePosition = Vector2.new(0, 0)
game:GetService("UserInputService").InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        mousePosition = Vector2.new(input.Position.X, input.Position.Y)
    end
end)

-- Функция для получения начальной точки трейсера
local function getTracerOrigin()
    local camera = game:GetService("Workspace").CurrentCamera
    local viewportSize = camera.ViewportSize
    
    if esp.tracer_origin == "Bottom" then
        return Vector2.new(viewportSize.X / 2, viewportSize.Y)
    elseif esp.tracer_origin == "Top" then
        return Vector2.new(viewportSize.X / 2, 0)
    elseif esp.tracer_origin == "Center" then
        return Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    elseif esp.tracer_origin == "Mouse" then
        return mousePosition
    else
        return Vector2.new(viewportSize.X / 2, viewportSize.Y) -- По умолчанию снизу
    end
end

-- Исправляем проблему с "застреванием" ESP элементов
-- Переопределяем функцию удаления ESP объектов
local originalRemove = esp.remove
esp.remove = function(self, plr)
    local objects = self.players[plr.Name]
    if objects then
        -- Принудительно скрываем все элементы перед удалением
        for i, v in next, objects do
            if i == 'chams' then
                if v.ins and v.ins.Parent then
                    v.ins.Enabled = false
                    v.ins:Destroy()
                end
            else
                if v and v.Visible ~= nil then
                    v.Visible = false
                end
                if v and v.Remove then
                    v:Remove()
                end
            end
        end
    end
    -- Очищаем из таблицы
    self.players[plr.Name] = nil
end

-- Переопределяем функцию отключения ESP для игрока
local originalDisable = esp.disable
esp.disable = function(self, plr)
    local objects = self.players[plr.Name]
    if objects then
        for i, v in next, objects do
            -- Принудительно скрываем все элементы
            if i == 'chams' then
                if v.ins then
                    v.ins.Enabled = false
                end
            else
                if v then
                    v.Visible = false
                end
            end
        end
    end
end

-- Сохраняем оригинальную функцию обновления ESP
local originalUpdate = esp.update

-- Переопределяем функцию update для поддержки настройки толщины полоски здоровья и трейсеров
esp.update = function()
    -- Очистка несуществующих игроков
    for plrName, _ in next, esp.players do
        local player = game:GetService('Players'):FindFirstChild(plrName)
        if not player then
            -- Игрок не существует, удаляем его ESP
            for _, obj in next, esp.players[plrName] do
                if _ == 'chams' then
                    if obj.ins then
                        obj.ins.Enabled = false
                        obj.ins:Destroy()
                    end
                else
                    if obj and obj.Visible ~= nil then
                        obj.Visible = false
                    end
                    if obj and obj.Remove then
                        obj:Remove()
                    end
                end
            end
            esp.players[plrName] = nil
            continue
        end
    end
    
    for plr, drawing in next, esp.players do
        local player = game:GetService('Players'):FindFirstChild(plr)
        if not player then esp.players[plr] = nil continue end
        
        if esp.enabled and esp.checkalive(player) then
            local character = esp:getcharacter(player)
            if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then
                esp:disable(player)
                continue
            end
            
            local pass = esp:check(player)
            local position, onScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(character.HumanoidRootPart.Position)
            local centerMassPos = character.HumanoidRootPart.CFrame
            local transparency = 1
            if esp.limitdistance then
                local distance = (game.Workspace.CurrentCamera.CFrame.Position - centerMassPos.Position).Magnitude
                if distance > esp.maxdistance then
                    esp:disable(player)
                    continue
                end
            end
            local health = math.floor(character.Humanoid.Health)
            
            -- Вызываем оригинальную функцию
            originalUpdate()
            
            -- Обновляем толщину полоски здоровья
            local flag = 'team_'
            if esp.checkteam(player, false) then flag = 'enemy_' end
            if table.find(esp.priority_players, player) then flag = 'priority_' end
            
            -- Обновляем толщину полоски здоровья
            if drawing.bar and drawing.bar.Visible then
                local smallestX, biggestX, smallestY, biggestY
                
                -- Находим координаты бокса
                for i, renderedObj in pairs(drawing) do
                    if i == 'box' and renderedObj.Visible then
                        smallestX = renderedObj.Position.X
                        smallestY = renderedObj.Position.Y
                        biggestX = smallestX + renderedObj.Size.X
                        biggestY = smallestY + renderedObj.Size.Y
                        break
                    end
                end
                
                if smallestX and smallestY and biggestY then
                    local thickness = esp.healthbar_thickness or 1
                    
                    -- Обновляем размеры и положение полоски здоровья
                    drawing.bar.Size = Vector2.new(thickness, (-health / 100 * (biggestY - smallestY + 2)) + 3) 
                    drawing.bar.Position = Vector2.new(smallestX - thickness - 2, smallestY + drawing.bar_outline.Size.Y)
                    
                    drawing.bar_inline.Size = Vector2.new(thickness, (- 1 * (biggestY - smallestY + 2)) + 3)
                    drawing.bar_inline.Position = drawing.bar.Position
                    
                    drawing.bar_outline.Size = Vector2.new(thickness, biggestY - smallestY)
                    drawing.bar_outline.Position = Vector2.new(smallestX - thickness - 1, smallestY + 1)
                end
            end
            
            -- Обновляем шрифт текстовых элементов
            if drawing.name and drawing.name.Visible then
                drawing.name.Font = Drawing.Fonts[esp.font] or 1 -- Применяем шрифт
            end
            
            if drawing.name_outline and drawing.name_outline.Visible then
                drawing.name_outline.Font = Drawing.Fonts[esp.font] or 1
            end
            
            if drawing.distance and drawing.distance.Visible then
                drawing.distance.Font = Drawing.Fonts[esp.font] or 1
            end
            
            if drawing.distance_outline and drawing.distance_outline.Visible then
                drawing.distance_outline.Font = Drawing.Fonts[esp.font] or 1
            end
            
            -- Обновляем трейсер
            if onScreen and position then
                -- Создаем трейсер, если его еще нет
                if not drawing.tracer then
                    drawing.tracer = Drawing.new("Line")
                    drawing.tracer.Thickness = esp.tracer_thickness
                    drawing.tracer.Color = esp.tracer_color
                    drawing.tracer.Transparency = 1
                    drawing.tracer.Visible = false
                end
                
                -- Обновляем видимость трейсера
                drawing.tracer.Visible = esp.tracers
                
                -- Если трейсеры включены, обновляем их позицию
                if esp.tracers then
                    local origin = getTracerOrigin()
                    drawing.tracer.From = origin
                    drawing.tracer.To = Vector2.new(position.X, position.Y)
                    drawing.tracer.Thickness = esp.tracer_thickness
                    drawing.tracer.Color = esp.tracer_color
                    drawing.tracer.Transparency = 1
                end
            elseif drawing.tracer then
                drawing.tracer.Visible = false
            end
            
            -- Всегда отключаем отображение оружия
            if drawing.weapon then
                drawing.weapon.Visible = false
            end
            if drawing.weapon_outline then
                drawing.weapon_outline.Visible = false
            end
        else
            esp:disable(player)
        end
    end
end

-- Создаем функцию для обработки шрифтов
local originalAddPlayer = esp.addplayer
esp.addplayer = function(self, plr)
    local ret = originalAddPlayer(self, plr)
    
    -- Если у игрока есть ESP элементы, устанавливаем для них шрифт
    if self.players[plr.Name] then
        local drawing = self.players[plr.Name]
        
        if drawing.name then
            drawing.name.Font = Drawing.Fonts[self.font] or 1
        end
        
        if drawing.name_outline then
            drawing.name_outline.Font = Drawing.Fonts[self.font] or 1
        end
        
        if drawing.distance then
            drawing.distance.Font = Drawing.Fonts[self.font] or 1
        end
        
        if drawing.distance_outline then
            drawing.distance_outline.Font = Drawing.Fonts[self.font] or 1
        end
        
        -- Добавляем трейсер, если он нужен
        if not drawing.tracer then
            drawing.tracer = Drawing.new("Line")
            drawing.tracer.Thickness = self.tracer_thickness
            drawing.tracer.Color = self.tracer_color
            drawing.tracer.Transparency = 1
            drawing.tracer.Visible = self.tracers
        end
    end
    
    return ret
end

-- Добавляем преобразование названий шрифтов в индексы
Drawing.Fonts = {
    ["Plex"] = 1,
    ["System"] = 2,
    ["UI"] = 3,
    ["Monospace"] = 4,
    ["SourceSans"] = 0
}

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Optimization Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local BotsFolder = Workspace:FindFirstChild("Bots") or Instance.new("Folder", Workspace)
local Inf = math.huge

-- Create the main window
local Window = Library:CreateWindow({
    Title = "TitanCX",
    Footer = "Cursed by 32vision",
    ShowCustomCursor = false,
})

local VisualsTab = Window:AddTab("Visuals", "eye")

-- ESP Section
local ESPGroupbox = VisualsTab:AddLeftGroupbox("ESP")

-- Основной переключатель ESP
local ESPToggle = ESPGroupbox:AddToggle("ESPEnabled", {
    Text = "ESP",
    Default = false,
    Tooltip = "Enables ESP visualization",
    Callback = function(Value)
        esp.enabled = Value
    end
})

-- Переключатель для боксов
local BoxesToggle = ESPGroupbox:AddToggle("Boxes", {
    Text = "Boxes",
    Default = false,
    Tooltip = "Displays boxes around players",
    Callback = function(Value)
        esp.team_boxes[1] = Value
    end
})

-- Добавляем выбор цвета для боксов
local BoxesColor = BoxesToggle:AddColorPicker("BoxesColor", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "Outline",
    Transparency = 0,
    Callback = function(Value)
        esp.team_boxes[2] = Value
    end
})

-- Добавляем выбор цвета заливки для боксов
local BoxesFillColor = BoxesToggle:AddColorPicker("BoxesFillColor", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "Fill",
    Transparency = 0,
    Callback = function(Value)
        esp.team_boxes[3] = Value
    end
})

-- Слайдер для прозрачности заливки
ESPGroupbox:AddSlider("BoxFillTransparency", {
    Text = "Transparency",
    Default = 0.2,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
        esp.team_boxes[4] = Value
    end
})

-- Переключатель для полосок здоровья
local HealthbarToggle = ESPGroupbox:AddToggle("Healthbar", {
    Text = "Healthbar",
    Default = false,
    Tooltip = "Displays health bars next to players",
    Callback = function(Value)
        esp.team_healthbar[1] = Value
    end
})

-- Выбор цвета для максимального здоровья
local HealthbarMaxColor = HealthbarToggle:AddColorPicker("HealthbarMaxColor", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "MaxHP",
    Transparency = 0,
    Callback = function(Value)
        esp.team_healthbar[2] = Value
    end
})

-- Выбор цвета для низкого здоровья
local HealthbarLowColor = HealthbarToggle:AddColorPicker("HealthbarLowColor", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "LowHP",
    Transparency = 0,
    Callback = function(Value)
        esp.team_healthbar[3] = Value
    end
})

-- Слайдер для настройки толщины полосок здоровья
ESPGroupbox:AddSlider("HealthbarThickness", {
    Text = "HPBarThickness",
    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Compact = false,
    Tooltip = "Adjusts the thickness of health bars in pixels",
    Callback = function(Value)
        esp.healthbar_thickness = Value
    end
})

-- Добавляем раздел для настройки дистанции
local DistanceSection = ESPGroupbox:AddDivider()

-- Переключатель для ограничения дистанции
local LimitDistanceToggle = ESPGroupbox:AddToggle("LimitDistance", {
    Text = "LimitDistance",
    Default = false,
    Tooltip = "Enable distance limit for ESP",
    Callback = function(Value)
        esp.limitdistance = Value
    end
})

-- Слайдер для максимальной дистанции
ESPGroupbox:AddSlider("MaxDistance", {
    Text = "MaxDistance",
    Default = 5000,
    Min = 100,
    Max = 10000,
    Rounding = 0,
    Suffix = "m",
    Compact = false,
    Tooltip = "Maximum distance to show ESP elements",
    Callback = function(Value)
        esp.maxdistance = Value
    end
})

-- Раздел для трейсеров
local TracersSection = ESPGroupbox:AddDivider()

-- Переключатель для трейсеров
local TracersToggle = ESPGroupbox:AddToggle("Tracers", {
    Text = "Tracers",
    Default = false,
    Tooltip = "Draw lines to players",
    Callback = function(Value)
        esp.tracers = Value
    end
})

-- Добавляем выбор цвета для трейсеров
local TracersColor = TracersToggle:AddColorPicker("TracersColor", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "Color",
    Transparency = 0,
    Callback = function(Value)
        esp.tracer_color = Value
    end
})

-- Выбор начальной точки трейсера
ESPGroupbox:AddDropdown("TracerOrigin", {
    Text = "Origin",
    Default = "Bottom",
    Values = {"Bottom", "Top", "Center"},
    Tooltip = "Where to draw tracers from",
    Callback = function(Value)
        esp.tracer_origin = Value
    end
})

-- Слайдер для толщины трейсеров
ESPGroupbox:AddSlider("TracerThickness", {
    Text = "Thickness",
    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Compact = false,
    Tooltip = "Tracer line thickness",
    Callback = function(Value)
        esp.tracer_thickness = Value
    end
})

-- Добавляем раздел для текстовых элементов
local TextSection = ESPGroupbox:AddDivider()

-- Переключатель для имен игроков
local NamesToggle = ESPGroupbox:AddToggle("Names", {
    Text = "Names",
    Default = false,
    Tooltip = "Show player names above boxes",
    Callback = function(Value)
        esp.team_names[1] = Value
    end
})

-- Выбор цвета для имен
local NamesColor = NamesToggle:AddColorPicker("NamesColor", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "Color",
    Transparency = 0,
    Callback = function(Value)
        esp.team_names[2] = Value
    end
})

-- Переключатель для дистанции
ESPGroupbox:AddToggle("Distance", {
    Text = "Distance",
    Default = false,
    Tooltip = "Show distance to players in meters",
    Callback = function(Value)
        esp.team_distance = Value
    end
})

-- Выпадающий список для выбора шрифта
local availableFonts = {"Plex", "System", "UI", "Monospace", "SourceSans"}
ESPGroupbox:AddDropdown("FontSelector", {
    Text = "Font",
    Default = "Plex",
    Values = availableFonts,
    Tooltip = "Select font for ESP text",
    Callback = function(Value)
        esp.font = Value
    end
})

-- Слайдер для размера текста
ESPGroupbox:AddSlider("TextSize", {
    Text = "TextSize",
    Default = 13,
    Min = 10,
    Max = 20,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        esp.textsize = Value
    end
})

-- Настройка фиксированных размеров
ESPGroupbox:AddToggle("FixedSizeToggle", {
    Text = "FixedSize",
    Default = true,
    Tooltip = "Use fixed size for ESP boxes",
    Callback = function(Value)
        esp.fixed_size_enabled = Value
    end
})

-- Слайдеры для настройки размеров боксов
ESPGroupbox:AddSlider("BoxWidthSlider", {
    Text = "Width",
    Default = 4,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        esp.fixed_box_width = Value
    end
})

ESPGroupbox:AddSlider("BoxHeightSlider", {
    Text = "Height",
    Default = 6,
    Min = 1,
    Max = 15,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        esp.fixed_box_height = Value
    end
})

-- Переключатель для проверки видимости
ESPGroupbox:AddToggle("VisibleCheck", {
    Text = "VisibleCheck",
    Default = false,
    Tooltip = "Only show ESP for visible players",
    Callback = function(Value)
        esp.visiblecheck = Value
    end
})

-- Добавляем переключатель для обводки
ESPGroupbox:AddToggle("Outlines", {
    Text = "Outlines",
    Default = true,
    Tooltip = "Enables outlines for ESP elements",
    Callback = function(Value)
        esp.outlines = Value
    end
})

-- Добавляем группбокс для Bullet Effects в правую часть вкладки
local BulletEffectsGroupbox = VisualsTab:AddRightGroupbox("Bullet Effects")

-- Локальная переменная для хранения настроек эффектов пуль
local bulletSettings = {
    -- Общие настройки
    enabled = true,
    
    -- Настройки для bullet tracers
    tracers = {
        enabled = false,
        gradient_color_1 = Color3.fromRGB(255, 255, 255),  -- Белый цвет
        gradient_color_2 = Color3.fromRGB(255, 255, 255),  -- Белый цвет
        duration = 2,                                  -- Продолжительность показа
        fade_enabled = true,                           -- Включено ли затухание
        fade_duration = 2,                             -- Продолжительность затухания
        texture = "rbxassetid://446111271",            -- Текстура для трейсера (Starhook по умолчанию)
        texture_length = 10,                           -- Длина текстуры
        width = 1,                                     -- Ширина трейсера
        light_emission = 1,                            -- Светоизлучение
        light_influence = 1                            -- Влияние света
    },
    
    -- Настройки для bullet impacts VFX
    impacts = {
        enabled = false,
        color = Color3.fromRGB(255, 255, 255),  -- Белый цвет
        size = 3,                           -- Размер эффекта частиц
        duration = 2,                       -- Продолжительность показа
        start_rotation = 0,                 -- Начальный угол поворота
        animation_speed = 1,                -- Скорость анимации вращения
        texture = "rbxassetid://81478735887868" -- Текстура частиц
    }
}

-- Доступные текстуры для трейсеров
local tracer_textures = {
    ["Starhook"] = "rbxassetid://446111271",
    ["Chain"] = "rbxassetid://3029306948",
    ["Lightning"] = "rbxassetid://7216850022",
    ["Beam"] = "rbxassetid://1263079249"
}

-- Раздел Bullet Tracers
BulletEffectsGroupbox:AddLabel("Bullet Tracers")

-- Переключатель для Bullet Tracers
local TracersToggle = BulletEffectsGroupbox:AddToggle("BulletTracers", {
    Text = "Tracers",
    Default = false,
    Tooltip = "Enable bullet tracers",
    Callback = function(Value)
        bulletSettings.tracers.enabled = Value
    end
})

-- Выбор текстуры трейсера
BulletEffectsGroupbox:AddDropdown("TracerTexture", {
    Text = "Texture",
    Default = "Starhook",
    Values = {"Starhook", "Chain", "Lightning", "Beam"},
    Tooltip = "Select texture for bullet tracers",
    Callback = function(Value)
        bulletSettings.tracers.texture = tracer_textures[Value]
    end
})

-- ColorPicker для начального цвета градиента
local TracerColor1 = TracersToggle:AddColorPicker("TracerColor1", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "Start",
    Transparency = 0,
    Callback = function(Value)
        bulletSettings.tracers.gradient_color_1 = Value
    end
})

-- ColorPicker для конечного цвета градиента
local TracerColor2 = TracersToggle:AddColorPicker("TracerColor2", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "End",
    Transparency = 0,
    Callback = function(Value)
        bulletSettings.tracers.gradient_color_2 = Value
    end
})

-- Слайдер для ширины трейсера
BulletEffectsGroupbox:AddSlider("TracerWidth", {
    Text = "Tracer Width",
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Tooltip = "Width of the bullet tracer beam",
    Callback = function(Value)
        bulletSettings.tracers.width = Value
    end
})

-- Раздел Bullet Impacts
BulletEffectsGroupbox:AddDivider()
BulletEffectsGroupbox:AddLabel("Bullet Impacts")

-- Переключатель для Bullet Impacts
local ImpactsToggle = BulletEffectsGroupbox:AddToggle("BulletImpacts", {
    Text = "Impacts",
    Default = false,
    Tooltip = "Enable bullet impact effects",
    Callback = function(Value)
        bulletSettings.impacts.enabled = Value
    end
})

-- ColorPicker для цвета эффекта попадания
local ImpactColor = ImpactsToggle:AddColorPicker("ImpactColor", {
    Default = Color3.fromRGB(255, 255, 255), -- Белый цвет
    Title = "Color",
    Transparency = 0,
    Callback = function(Value)
        bulletSettings.impacts.color = Value
    end
})

-- Слайдер для размера эффекта попадания
BulletEffectsGroupbox:AddSlider("ImpactSize", {
    Text = "Impact Size",
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Tooltip = "Size of the impact effect",
    Callback = function(Value)
        bulletSettings.impacts.size = Value
    end
})

-- Слайдер для скорости анимации
BulletEffectsGroupbox:AddSlider("AnimationSpeed", {
    Text = "Animation Speed",
    Default = 1,
    Min = 0,
    Max = 5,
    Rounding = 2,
    Compact = false,
    Tooltip = "Animation speed for impact effects",
    Callback = function(Value)
        bulletSettings.impacts.animation_speed = Value
    end
})

-- Слайдер для начального угла поворота
BulletEffectsGroupbox:AddSlider("StartRotation", {
    Text = "Start Rotation",
    Default = 0,
    Min = 0,
    Max = 360,
    Rounding = 0,
    Compact = false,
    Tooltip = "Initial rotation angle in degrees",
    Callback = function(Value)
        bulletSettings.impacts.start_rotation = Value
    end
})

-- Глобальная функция для получения настроек пуль (чтобы другие модули могли использовать)
getgenv().GetBulletSettings = function()
    return bulletSettings
end

-- Добавляем реализацию Bullet Tracers и Impacts
local function InitializeBulletEffects()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")
    local Workspace = game:GetService("Workspace")

    -- Получаем локального игрока
    local LocalPlayer = Players.LocalPlayer

    -- Переменные для отслеживания выстрелов локального игрока
    local gunState = {
        current_tool = nil,
        previous_ammo = 0,
        recently_shot = false,
        connections = {}
    }

    -- Функция определения игры и путей к пулям
    local function detectGame()
        local placeId = game.PlaceId
        
        local gameData = {
            -- Da Hood
            [2788229376] = {
                Name = "Da Hood",
                Remote = "MainEvent",
                Argument = "UpdateMousePosI",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") and Workspace.Ignored:FindFirstChild("Siren") and Workspace.Ignored.Siren:FindFirstChild("Radius") or nil
            },
            -- Del hood
            [71189885129233] = {
                Name = "Del hood",
                Remote = "MainEvent",
                Argument = "UpdateMousePos",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") or nil
            },
            -- Hood Modded
            [5602055394] = {
                Name = "Hood Modded",
                Remote = "MAINEVENT",
                Argument = "MousePos",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") or nil
            },
            -- Da Downhill
            [17403265390] = {
                Name = "Da Downhill",
                Remote = "MAINEVENT",
                Argument = "MOUSE",
                BulletName = "Part",
                BulletBeamName = "gb",
                BulletPath = Workspace
            },
            -- Da Bank
            [17403166075] = {
                Name = "Da Bank",
                Remote = "MAINEVENT",
                Argument = "MOUSE",
                BulletName = "Part",
                BulletBeamName = "gb",
                BulletPath = Workspace
            },
            -- Da Uphill
            [18111448661] = {
                Name = "Da Uphill",
                Remote = "MAINEVENT",
                Argument = "MOUSE",
                BulletName = "Part",
                BulletBeamName = "gb",
                BulletPath = Workspace
            },
            -- Da Strike
            [15186202290] = {
                Name = "Da Strike",
                Remote = "MAINEVENT",
                Argument = "MOUSE",
                BulletName = "Part",
                BulletBeamName = "gb",
                BulletPath = Workspace
            },
            -- 1v1 Hood Aim Trainer
            [11143225577] = {
                Name = "1v1 Hood Aim Trainer",
                Remote = "MAINEVENT",
                Argument = "UpdateMousePos",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace
            },
            -- Hood Aim
            [15763494605] = {
                Name = "Hood Aim",
                Remote = "MAINEVENT",
                Argument = "MOUSE",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace
            },
            -- Moon Hood
            [15166543806] = {
                Name = "Moon Hood",
                Remote = "MAINEVENT",
                Argument = "MoonUpdateMousePos",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace
            },
            -- OG Da Hood
            [17897702920] = {
                Name = "OG Da Hood",
                Remote = "MainEvent",
                Argument = "UpdateMousePos",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace
            },
            -- Da Hood Macro
            [16033173781] = {
                Name = "Da Hood Macro",
                Remote = "MainEvent",
                Argument = "UpdateMousePosI",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") and Workspace.Ignored:FindFirstChild("Siren") and Workspace.Ignored.Siren:FindFirstChild("Radius") or nil
            },
            -- Da Hood VC
            [7213786345] = {
                Name = "Da Hood VC",
                Remote = "MainEvent",
                Argument = "UpdateMousePosI",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") and Workspace.Ignored:FindFirstChild("Siren") and Workspace.Ignored.Siren:FindFirstChild("Radius") or nil
            },
            -- Hood Customs
            [9825515356] = {
                Name = "Hood Customs",
                Remote = "MainEvent",
                Argument = "MousePosUpdate",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") or nil
            },
            -- Hood Z
            [16859411452] = {
                Name = "Hood Z",
                Remote = "MainEvent",
                Argument = "UpdateMousePos",
                BulletName = "bulletray",
                BulletBeamName = "beam",
                BulletPath = Workspace:FindFirstChild("Ignored") or nil
            },
            -- Custom FFA
            [14277620939] = {
                Name = "Custom FFA",
                Remote = "MainEvent",
                Argument = "UpdateMousePos",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") or nil
            },
            -- Fallback для неизвестных игр
            [0] = {
                Name = "Неизвестная Hood игра",
                Remote = "MainEvent",
                Argument = "UpdateMousePos",
                BulletName = "BULLET_RAYS",
                BulletBeamName = "GunBeam",
                BulletPath = Workspace:FindFirstChild("Ignored") or Workspace
            }
        }
        
        local data = gameData[placeId] or gameData[0]
        
        -- Если BulletPath не указан, пробуем найти его в зависимости от игры
        if not data.BulletPath or data.BulletPath == nil then
            data.BulletPath = Workspace:FindFirstChild("Ignored") or Workspace
        end
        
        return data
    end

    -- Создание луча (beam)
    local function createBeam(from, to, color_1, color_2, duration, fade_enabled, fade_duration, beam_settings)
        local tween
        local total_time = 0

        -- Создаем невидимую основную часть
        local main_part = Instance.new("Part")
        main_part.Name = "BulletTracer"
        main_part.Parent = Workspace
        main_part.Size = Vector3.new(0, 0, 0)
        main_part.Massless = true
        main_part.Transparency = 1
        main_part.CanCollide = false
        main_part.Position = from
        main_part.Anchored = true

        -- Создаем две точки для луча
        local part0 = Instance.new("Part")
        part0.Parent = main_part
        part0.Size = Vector3.new(0, 0, 0)
        part0.Massless = true
        part0.Transparency = 1
        part0.CanCollide = false
        part0.Position = from
        part0.Anchored = true

        local part1 = Instance.new("Part")
        part1.Parent = main_part
        part1.Size = Vector3.new(0, 0, 0)
        part1.Massless = true
        part1.Transparency = 1
        part1.CanCollide = false
        part1.Position = to
        part1.Anchored = true

        -- Создаем точки крепления для луча
        local attachment0 = Instance.new("Attachment")
        attachment0.Parent = part0

        local attachment1 = Instance.new("Attachment")
        attachment1.Parent = part1

        -- Создаем сам луч с градиентом цвета
        local beam = Instance.new("Beam")
        beam.Texture = beam_settings.texture
        beam.TextureMode = Enum.TextureMode.Wrap
        beam.TextureLength = beam_settings.texture_length
        beam.LightEmission = beam_settings.light_emission
        beam.LightInfluence = beam_settings.light_influence
        beam.Width0 = beam_settings.width -- Ширина в начале трейсера
        beam.Width1 = beam_settings.width -- Ширина в конце трейсера
        beam.FaceCamera = true
        beam.ZOffset = -1
        beam.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(1, 1),
        })
        beam.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, color_1),
            ColorSequenceKeypoint.new(1, color_2),
        })
        beam.Attachment0 = attachment0
        beam.Attachment1 = attachment1
        beam.Enabled = true
        beam.Parent = main_part

        -- Эффект затухания
        if fade_enabled then
            tween = RunService.Heartbeat:Connect(function(delta_time)
                total_time = total_time + delta_time
                beam.Transparency = NumberSequence.new(TweenService:GetValue((total_time / fade_duration), Enum.EasingStyle.Quad, Enum.EasingDirection.In))
            end)
        end

        -- Уничтожаем луч через указанное время
        task.delay(duration, function()
            if tween then
                tween:Disconnect()
            end
            main_part:Destroy()
        end)
    end

    -- Создание VFX эффекта попадания пули
    local function createVFXImpact(color, size, duration, texture, position, start_rotation, animation_speed)
        -- Создаем прозрачный объект для эффекта
        local impactPart = Instance.new("Part")
        impactPart.Name = "VFXBulletImpact"
        impactPart.Transparency = 1
        impactPart.CanCollide = false
        impactPart.Anchored = true
        impactPart.Size = Vector3.new(0.2, 0.2, 0.2) -- Меньший размер, так как BillboardGui будет визуальным элементом
        impactPart.Position = position
        impactPart.Parent = Workspace
        
        -- Создаем BillboardGui
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ImpactBillboard"
        billboard.Adornee = impactPart
        billboard.Size = UDim2.new(size, 0, size, 0) -- Размер эффекта, аналогичный ParticleEmitter
        billboard.StudsOffset = Vector3.new(0, 0, 0)
        billboard.AlwaysOnTop = true -- Ключевое свойство: рендерится поверх всех объектов
        billboard.Parent = impactPart
        
        -- Создаем ImageLabel для текстуры
        local imageLabel = Instance.new("ImageLabel")
        imageLabel.Size = UDim2.new(1, 0, 1, 0)
        imageLabel.BackgroundTransparency = 1
        imageLabel.Image = texture -- Используем ту же текстуру
        imageLabel.ImageColor3 = color -- Применяем цвет
        imageLabel.Rotation = start_rotation -- Начальный угол поворота
        imageLabel.Parent = billboard
        
        -- Добавляем вращение, скорректированное на скорость анимации
        local rotationTween = TweenService:Create(imageLabel, TweenInfo.new(duration * (animation_speed > 0 and animation_speed or 0.001), Enum.EasingStyle.Linear), {
            Rotation = start_rotation + 360 -- Вращение на 360 градусов от начального угла
        })
        rotationTween:Play()
        
        -- Анимация прозрачности для имитации ParticleEmitter
        local transparencyTween = TweenService:Create(imageLabel, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
            ImageTransparency = 1 -- Затухание до полной прозрачности
        })
        transparencyTween:Play()
        
        -- Удаляем эффект через указанное время
        task.delay(duration, function()
            impactPart:Destroy()
        end)
    end

    -- Функция для получения оружия локального игрока
    local function getGun(player)
        if not player or not player.Character then return nil end
        
        local tool = player.Character:FindFirstChildWhichIsA("Tool")
        if not tool then return nil end
        
        local gunInfo = {}
        
        -- Ищем значение патронов в оружии
        local descendants = tool:GetDescendants()
        for _, obj in ipairs(descendants) do
            if (string.lower(obj.Name):find("ammo") and not string.lower(obj.Name):find("max") and
                (obj.ClassName == "IntValue" or obj.ClassName == "NumberValue")) then
                gunInfo.ammo = obj
                gunInfo.tool = tool
                return gunInfo
            end
        end
        
        return nil
    end

    -- Функция для настройки отслеживания оружия
    local function setupGunTracking(player)
        -- Очищаем текущие соединения
        for _, connection in ipairs(gunState.connections) do
            if connection then connection:Disconnect() end
        end
        gunState.connections = {}
        
        -- Если персонаж игрока не существует, создаем соединение на его появление
        if not player.Character then
            table.insert(gunState.connections, player.CharacterAdded:Connect(function(character)
                setupGunTracking(player)
            end))
            return
        end
        
        -- Отслеживаем добавление/удаление оружия
        table.insert(gunState.connections, player.Character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                local gun = getGun(player)
                if gun then
                    gunState.current_tool = gun.tool
                    gunState.previous_ammo = gun.ammo.Value
                    
                    -- Отслеживаем изменение количества патронов
                    table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
                        local new_ammo = gun.ammo.Value
                        if new_ammo < gunState.previous_ammo then
                            gunState.recently_shot = true
                            task.wait() -- Короткая пауза для обнаружения пули
                            gunState.recently_shot = false
                        end
                        gunState.previous_ammo = new_ammo
                    end))
                end
            end
        end))
        
        table.insert(gunState.connections, player.Character.ChildRemoved:Connect(function(child)
            if child == gunState.current_tool then
                gunState.current_tool = nil
                gunState.previous_ammo = 0
            end
        end))
        
        -- Проверяем наличие оружия сразу
        local gun = getGun(player)
        if gun then
            gunState.current_tool = gun.tool
            gunState.previous_ammo = gun.ammo.Value
            
            -- Отслеживаем изменение количества патронов
            table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
                local new_ammo = gun.ammo.Value
                if new_ammo < gunState.previous_ammo then
                    gunState.recently_shot = true
                    task.wait() -- Короткая пауза для обнаружения пули
                    gunState.recently_shot = false
                end
                gunState.previous_ammo = new_ammo
            end))
        end
    end

    -- Основная функция
    local function setupBulletEffects()
        local gameData = detectGame()
        
        if not gameData.BulletPath then
            return
        end
        
        -- Настраиваем отслеживание оружия локального игрока
        setupGunTracking(LocalPlayer)
        
        -- Отслеживаем добавление персонажа, если он еще не существует
        if not LocalPlayer.Character then
            LocalPlayer.CharacterAdded:Connect(function(character)
                setupGunTracking(LocalPlayer)
            end)
        end
        
        -- Следим за созданием новых пуль
        gameData.BulletPath.ChildAdded:Connect(function(object)
            -- Используем настройки из UI
            local settings = GetBulletSettings()
            if not settings.enabled then return end
            
            -- Проверяем, чтобы это была пуля с правильным именем и недавно выстрелил локальный игрок
            if object.Name == gameData.BulletName and gunState.recently_shot then
                local gunBeam = object:WaitForChild(gameData.BulletBeamName, 1)
                if not gunBeam then return end
                
                local startPos = object.Position
                local endPos = gunBeam.Attachment1.WorldPosition
                
                -- Создаем трейсер, если включен
                if settings.tracers.enabled then
                    -- Удаляем оригинальный луч
                    gunBeam:Destroy()
                    
                    -- Предварительно готовим настройки для beam
                    local beam_settings = {
                        texture = settings.tracers.texture,
                        texture_length = settings.tracers.texture_length,
                        light_emission = settings.tracers.light_emission,
                        light_influence = settings.tracers.light_influence,
                        width = settings.tracers.width
                    }
                    
                    createBeam(
                        startPos, 
                        endPos, 
                        settings.tracers.gradient_color_1, 
                        settings.tracers.gradient_color_2, 
                        settings.tracers.duration, 
                        settings.tracers.fade_enabled, 
                        settings.tracers.fade_duration,
                        beam_settings
                    )
                end
                
                -- Создаем VFX эффект попадания, если включен
                if settings.impacts.enabled then
                    createVFXImpact(
                        settings.impacts.color, 
                        settings.impacts.size, 
                        settings.impacts.duration, 
                        settings.impacts.texture, 
                        endPos,
                        settings.impacts.start_rotation,
                        settings.impacts.animation_speed
                    )
                end
            end
        end)
    end

    -- Запускаем отслеживание пуль
    setupBulletEffects()
end

-- Запускаем скрипт для Bullet Effects
InitializeBulletEffects()

-- Добавляем группбокс для Self Chams в правую часть вкладки
local SelfChamsGroupbox = VisualsTab:AddRightGroupbox("Self Chams")

-- Локальная переменная для хранения настроек SelfChams
local selfChamsSettings = {
    bodyParts = {
        apply = false,
        addHighlight = false,
        rainbow = false,
        highlightSettings = {
            FillTransparency = 0.5,
            OutlineTransparency = 0,
            FillColor = Color3.new(1, 1, 1),
            OutlineColor = Color3.new(1, 1, 1)
        }
    },
    accessories = {
        apply = false,
        addHighlight = false,
        rainbow = false,
        highlightSettings = {
            FillTransparency = 0.7,
            OutlineTransparency = 0,
            FillColor = Color3.new(1, 1, 1),
            OutlineColor = Color3.new(1, 1, 1)
        }
    },
    heldItems = {
        apply = false,
        rainbow = false
    },
    enabled = false
}

-- Таблицы для хранения оригинальных свойств и соединений
local originalProps = {}
local rainbowConnections = {}
local characterAddedConnection
local heldItemsConnection

-- Главный переключатель SelfChams
local SelfChamsEnabled = SelfChamsGroupbox:AddToggle("SelfChamsEnabled", {
    Text = "Enabled",
    Default = false,
    Tooltip = "Включить Self Chams",
    Callback = function(Value)
        selfChamsSettings.enabled = Value
        
        if Value then applySelfChams()
        else removeSelfChams() end
    end
})

-- Раздел для настроек частей тела
SelfChamsGroupbox:AddDivider()
SelfChamsGroupbox:AddLabel("Body Parts")

local BodyPartsApply = SelfChamsGroupbox:AddToggle("BodyPartsApply", {
    Text = "ForceField",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.bodyParts.apply = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

local BodyPartsHighlight = SelfChamsGroupbox:AddToggle("BodyPartsHighlight", {
    Text = "Highlight",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.bodyParts.addHighlight = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

local BodyPartsRainbow = SelfChamsGroupbox:AddToggle("BodyPartsRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.bodyParts.rainbow = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

local BodyPartsFillColor = BodyPartsHighlight:AddColorPicker("BodyPartsFillColor", {
    Default = Color3.new(1, 1, 1),
    Title = "Fill",
    Callback = function(Value)
        selfChamsSettings.bodyParts.highlightSettings.FillColor = Value
        if selfChamsSettings.enabled and not selfChamsSettings.bodyParts.rainbow then updateSelfChams() end
    end
})

local BodyPartsOutlineColor = BodyPartsHighlight:AddColorPicker("BodyPartsOutlineColor", {
    Default = Color3.new(1, 1, 1),
    Title = "Outline",
    Callback = function(Value)
        selfChamsSettings.bodyParts.highlightSettings.OutlineColor = Value
        if selfChamsSettings.enabled and not selfChamsSettings.bodyParts.rainbow then updateSelfChams() end
    end
})

SelfChamsGroupbox:AddSlider("BodyPartsFillTrans", {
    Text = "Fill Trans",
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(Value)
        selfChamsSettings.bodyParts.highlightSettings.FillTransparency = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

SelfChamsGroupbox:AddSlider("BodyPartsOutlineTrans", {
    Text = "Outline Trans",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(Value)
        selfChamsSettings.bodyParts.highlightSettings.OutlineTransparency = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

-- Раздел для настроек аксессуаров
SelfChamsGroupbox:AddDivider()
SelfChamsGroupbox:AddLabel("Accessories")

local AccessoriesApply = SelfChamsGroupbox:AddToggle("AccessoriesApply", {
    Text = "ForceField",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.accessories.apply = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

local AccessoriesHighlight = SelfChamsGroupbox:AddToggle("AccessoriesHighlight", {
    Text = "Highlight",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.accessories.addHighlight = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

local AccessoriesRainbow = SelfChamsGroupbox:AddToggle("AccessoriesRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.accessories.rainbow = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

local AccessoriesFillColor = AccessoriesHighlight:AddColorPicker("AccessoriesFillColor", {
    Default = Color3.new(1, 1, 1),
    Title = "Fill",
    Callback = function(Value)
        selfChamsSettings.accessories.highlightSettings.FillColor = Value
        if selfChamsSettings.enabled and not selfChamsSettings.accessories.rainbow then updateSelfChams() end
    end
})

local AccessoriesOutlineColor = AccessoriesHighlight:AddColorPicker("AccessoriesOutlineColor", {
    Default = Color3.new(1, 1, 1),
    Title = "Outline",
    Callback = function(Value)
        selfChamsSettings.accessories.highlightSettings.OutlineColor = Value
        if selfChamsSettings.enabled and not selfChamsSettings.accessories.rainbow then updateSelfChams() end
    end
})

SelfChamsGroupbox:AddSlider("AccessoriesFillTrans", {
    Text = "Fill Trans",
    Default = 0.7,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(Value)
        selfChamsSettings.accessories.highlightSettings.FillTransparency = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

SelfChamsGroupbox:AddSlider("AccessoriesOutlineTrans", {
    Text = "Outline Trans",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(Value)
        selfChamsSettings.accessories.highlightSettings.OutlineTransparency = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

-- Раздел для настроек предметов в руках
SelfChamsGroupbox:AddDivider()
SelfChamsGroupbox:AddLabel("Held Items")

local HeldItemsApply = SelfChamsGroupbox:AddToggle("HeldItemsApply", {
    Text = "ForceField",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.heldItems.apply = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

local HeldItemsRainbow = SelfChamsGroupbox:AddToggle("HeldItemsRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(Value)
        selfChamsSettings.heldItems.rainbow = Value
        if selfChamsSettings.enabled then updateSelfChams() end
    end
})

-- Функции для Self Chams
-- Функция для генерации радужного цвета
local function getRainbowColor()
    local hue = (tick() % 10) / 10
    return Color3.fromHSV(hue, 1, 1)
end

-- Функция для создания или обновления Highlight
local function applyHighlight(part, highlightSettings, rainbow)
    local highlight = part:FindFirstChildOfClass("Highlight") or Instance.new("Highlight", part)
    highlight.FillTransparency = highlightSettings.FillTransparency
    highlight.OutlineTransparency = highlightSettings.OutlineTransparency
    
    if rainbow then
        local rainbowColor = getRainbowColor()
        highlight.FillColor = rainbowColor
        highlight.OutlineColor = rainbowColor
    else
        highlight.FillColor = highlightSettings.FillColor
        highlight.OutlineColor = highlightSettings.OutlineColor
    end
    
    highlight.Adornee = part
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    return highlight
end

-- Функция для сохранения свойств и применения эффектов
local function updateParts(character, category, partsFn)
    if not character then return end
    
    local cfg = selfChamsSettings[category]
    if not cfg then return end
    
    for _, part in pairs(partsFn(character)) do
        -- Сохраняем оригинальные свойства, если еще не сохранены
        if not originalProps[part] then
            originalProps[part] = {
                Color = part.Color,
                Material = part.Material
            }
        end
        
        -- Применяем ForceField
        if cfg.apply then
            if cfg.rainbow then part.Color = getRainbowColor()
            else part.Color = (cfg.highlightSettings and cfg.highlightSettings.FillColor) or Color3.new(1,1,1) end
            part.Material = Enum.Material.ForceField
        end
        
        -- Применяем хайлайт, если нужно
        if cfg.addHighlight and cfg.highlightSettings then
            applyHighlight(part, cfg.highlightSettings, cfg.rainbow)
        else
            -- Удаляем хайлайт, если он есть, но не должен быть
            local highlight = part:FindFirstChildOfClass("Highlight")
            if highlight then highlight:Destroy() end
        end
    end
end

-- Функция для восстановления свойств части персонажа
local function restorePart(part)
    if not part or not originalProps[part] then return end
    
    -- Сначала восстанавливаем материал, затем цвет
    part.Material = originalProps[part].Material
    part.Color = originalProps[part].Color
    
    -- Удаляем хайлайт
    local highlight = part:FindFirstChildOfClass("Highlight")
    if highlight then highlight:Destroy() end
end

-- Обновляем внешний вид персонажа
function updateSelfChams()
    local character = Players.LocalPlayer.Character
    if not character then return end
    
    -- Обновляем части тела
    updateParts(character, "bodyParts", function(char)
        local parts = {}
        for _, part in pairs(char:GetChildren()) do
            if part:IsA("BasePart") then table.insert(parts, part) end
        end
        return parts
    end)
    
    -- Обновляем аксессуары
    updateParts(character, "accessories", function(char)
        local parts = {}
        for _, accessory in pairs(char:GetChildren()) do
            if accessory:IsA("Accessory") then
                local handle = accessory:FindFirstChild("Handle")
                if handle and handle:IsA("BasePart") then table.insert(parts, handle) end
            end
        end
        return parts
    end)
    
    -- Обновляем предметы в руках
    updateParts(character, "heldItems", function(char)
        local parts = {}
        local tool = char:FindFirstChildOfClass("Tool")
        if tool then
            for _, part in pairs(tool:GetDescendants()) do
                if part:IsA("BasePart") then table.insert(parts, part) end
            end
        end
        return parts
    end)
    
    -- Обновляем подключения
    setupConnections()
end

-- Настройка подключений
function setupConnections()
    -- Отключаем существующие подключения
    for _, connection in pairs(rainbowConnections) do
        if connection then connection:Disconnect() end
    end
    rainbowConnections = {}
    
    -- Обработка CharacterAdded
    if characterAddedConnection then characterAddedConnection:Disconnect() end
    characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        if not selfChamsSettings.enabled then return end
        task.wait(0.5) -- Задержка для загрузки персонажа
        updateSelfChams()
    end)
    
    -- Если включен радужный режим, настраиваем обновление
    local needsRainbowUpdate = 
        (selfChamsSettings.bodyParts.rainbow and (selfChamsSettings.bodyParts.apply or selfChamsSettings.bodyParts.addHighlight)) or
        (selfChamsSettings.accessories.rainbow and (selfChamsSettings.accessories.apply or selfChamsSettings.accessories.addHighlight)) or
        (selfChamsSettings.heldItems.rainbow and selfChamsSettings.heldItems.apply)
    
    if needsRainbowUpdate then
        local connection = RunService.Heartbeat:Connect(function()
            if not selfChamsSettings.enabled then return end
            updateSelfChams()
        end)
        table.insert(rainbowConnections, connection)
    else
        -- Обработка предметов в руках, если нет радужного режима
        if selfChamsSettings.heldItems.apply then
            if heldItemsConnection then heldItemsConnection:Disconnect() end
            heldItemsConnection = RunService.Heartbeat:Connect(function()
                if not selfChamsSettings.enabled then return end
                
                local character = Players.LocalPlayer.Character
                if character then
                    updateParts(character, "heldItems", function(char)
                        local parts = {}
                        local tool = char:FindFirstChildOfClass("Tool")
                        if tool then
                            for _, part in pairs(tool:GetDescendants()) do
                                if part:IsA("BasePart") then table.insert(parts, part) end
                            end
                        end
                        return parts
                    end)
                end
            end)
        end
    end
end

-- Применяем Self Chams
function applySelfChams()
    -- Очищаем оригинальные свойства
    originalProps = {}
    updateSelfChams()
end

-- Удаляем Self Chams
function removeSelfChams()
    -- Отключаем все подключения
    for _, connection in pairs(rainbowConnections) do
        if connection then connection:Disconnect() end
    end
    rainbowConnections = {}
    
    if heldItemsConnection then
        heldItemsConnection:Disconnect()
        heldItemsConnection = nil
    end
    
    if characterAddedConnection then
        characterAddedConnection:Disconnect()
        characterAddedConnection = nil
    end
    
    -- Восстанавливаем оригинальные свойства
    local character = Players.LocalPlayer.Character
    if not character then return end
    
    -- Восстанавливаем части тела
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then restorePart(part) end
    end
    
    -- Восстанавливаем аксессуары
    for _, accessory in pairs(character:GetChildren()) do
        if accessory:IsA("Accessory") then
            local handle = accessory:FindFirstChild("Handle")
            if handle and handle:IsA("BasePart") then restorePart(handle) end
        end
    end
    
    -- Восстанавливаем предметы в руках
    local tool = character:FindFirstChildOfClass("Tool")
    if tool then
        for _, part in pairs(tool:GetDescendants()) do
            if part:IsA("BasePart") then restorePart(part) end
        end
    end
    
    -- Очищаем таблицу оригинальных свойств
    originalProps = {}
end

-- Глобальная функция для получения настроек Self Chams
getgenv().GetSelfChamsSettings = function()
    return selfChamsSettings
end

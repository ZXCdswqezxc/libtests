-- Загрузка библиотеки
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/ZXCdswqezxc/libtests/refs/heads/main/library"))()

-- Создание кастомной ватермарки
local watermark = {}

do
    -- Функция для форматирования даты
    local function get_date_text()
        local date = os.date("*t")
        return string.format("replace.gg | %02d.%02d.%d %02d:%02d:%02d", 
            date.day, date.month, date.year, date.hour, date.min, date.sec)
    end

    -- Создаем элементы UI для ватермарки
    local holder = library:create("Frame", {
        Parent = library.gui,
        Name = "CustomWatermark",
        BackgroundTransparency = 1,
        Position = UDim2.new(0, 20, 0, 20),
        BorderColor3 = Color3.fromRGB(19, 19, 19),
        ZIndex = 2,
        AutomaticSize = Enum.AutomaticSize.X,
        BackgroundColor3 = Color3.fromRGB(40, 40, 40),
        Visible = false -- По умолчанию скрыто
    })
    
    local inline1 = library:create("Frame", {
        Parent = holder,
        Name = "",
        Active = true, 
        Draggable = true, 
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(0, 250, 0, 40), -- Увеличил размер для отображения полной даты
        BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    })
    
    local accent_line = library:create("Frame", {
        Parent = inline1,
        Name = "",
        BorderColor3 = Color3.fromRGB(34, 34, 34),
        Size = UDim2.new(1, 0, 0, 2),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    })

    -- Подключаем акцентный цвет к теме
    library:apply_theme(accent_line, "accent", "BackgroundColor3") 
    
    local depth = library:create("Frame", {
        Parent = inline1,
        Name = "",
        BackgroundTransparency = 0.5,
        Position = UDim2.new(0, 0, 0, 1),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(1, 0, 0, 1),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    })
    
    local inline2 = library:create("Frame", {
        Parent = inline1,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(1, -4, 1, -4),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(26, 26, 26)
    })
    
    local main = library:create("Frame", {
        Parent = inline2,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(57, 57, 57),
        Size = UDim2.new(1, -4, 1, -4),
        BackgroundColor3 = Color3.fromRGB(26, 26, 26)
    })
    
    local tab_inline = library:create("Frame", {
        Parent = main,
        Name = "",
        Position = UDim2.new(0, 6, 0, 6),
        BorderColor3 = Color3.fromRGB(19, 19, 19),
        Size = UDim2.new(1, -12, 1, -12),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(19, 19, 19)
    })
    
    local tabs = library:create("Frame", {
        Parent = tab_inline,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(56, 56, 56),
        Size = UDim2.new(1, -4, 1, -4),
        BackgroundColor3 = Color3.fromRGB(22, 22, 22)
    })
    
    local name_label = library:create("TextLabel", {
        Parent = tabs,
        Name = "",
        FontFace = library.font,
        TextColor3 = Color3.fromRGB(100, 100, 255), -- Цвет акцента по умолчанию
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Text = get_date_text(),
        TextStrokeTransparency = 0.5,
        Size = UDim2.new(0, 0, 1, 0),
        Position = UDim2.new(0, 8, 0, 0),
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
        BorderSizePixel = 0,
        AutomaticSize = Enum.AutomaticSize.X,
        TextSize = 12,
        BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    })
    
    -- Подключаем цвет текста к акцентному цвету
    library:apply_theme(name_label, "accent", "TextColor3")
    
    local padding = library:create("UIPadding", {
        Parent = tabs,
        Name = "",
        PaddingRight = UDim.new(0, 21)
    })
    
    local glow = library:create("ImageLabel", {
        Parent = accent_line,
        Name = "",
        ImageColor3 = Color3.fromRGB(100, 100, 255),
        ScaleType = Enum.ScaleType.Slice,
        ImageTransparency = 0.8999999761581421,
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        Image = "http://www.roblox.com/asset/?id=18245826428",
        BackgroundTransparency = 1,
        Position = UDim2.new(0, -20, 0, -20),
        Size = UDim2.new(1, 40, 0, 42),
        ZIndex = 2,
        BorderSizePixel = 0,
        SliceCenter = Rect.new(Vector2.new(21, 21), Vector2.new(79, 79))
    })

    -- Подключаем свечение к акцентному цвету
    library:apply_theme(glow, "accent", "ImageColor3")
    
    -- Функционал ватермарки
    watermark = {
        holder = holder,
        
        -- Функция для переключения видимости
        toggle = function(state)
            holder.Visible = state
            
            -- Если включаем ватермарку, сразу обновляем текст даты
            if state then
                watermark.update_date()
            end
        end,
        
        -- Функция для обновления текста
        update_text = function(text)
            name_label.Text = text
            -- Обновляем размер для нового текста
            inline1.Size = UDim2.new(0, ((#text / 2) * 5) + 100, 0, 40)
        end,
        
        -- Функция для обновления даты
        update_date = function()
            watermark.update_text(get_date_text())
        end
    }
    
    -- Запускаем таймер для обновления даты (каждую секунду)
    task.spawn(function()
        while true do
            task.wait(1) -- Обновляем дату каждую секунду
            
            -- Обновляем только если ватермарка видима
            if holder.Visible then
                watermark.update_date()
            end
        end
    end)
end

-- Создаём окно с 6 вкладками
local win = library:window{
    name = "replace.gg",
}

-- Скрываем все UI элементы при запуске
win.toggle_watermark(false)    -- Скрываем встроенный водяной знак
win.toggle_list(false)         -- Скрываем список привязок клавиш
win.toggle_playerlist(false)   -- Скрываем список игроков

local tabs = {
    Combat = win:tab{name = "Combat"},
    Movement = win:tab{name = "Movement"},
    Visuals = win:tab{name = "Visuals"},
    Misc = win:tab{name = "Misc"},
    Other = win:tab{name = "Other"},
    Config = win:tab{name = "Config"}
}

-- Добавляем секции в Misc вкладку
local misc_sections = {
    camera = tabs.Misc:section{name = "Camera", side = "left"},
    extras = tabs.Misc:section{name = "Extras", side = "right"}
}

-- Добавляем toggle для Infinity Zoom
misc_sections.camera:toggle{
    name = "Infinity Zoom",
    flag = "infinity_zoom",
    default = false,
    callback = function(state)
        if state then
            game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
        else
            -- Возвращаем стандартное значение при отключении
            game.Players.LocalPlayer.CameraMaxZoomDistance = 128
        end
    end
}

-- Добавляем секции в Config вкладку
local config_sections = {
    configs = tabs.Config:section{name = "Configurations", side = "left"},
    menu = tabs.Config:section{name = "Menu Settings", side = "right"}
}

-- Настройка секции конфигураций
config_sections.configs:textbox{
    name = "Configuration Name",
    flag = "config_name",
    placeholder = "default",
    clear_on_focus = false,
    default = "default"
}

config_sections.configs:button{
    name = "Save Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        local config_data = library:get_config()
        
        -- Сохранение в файл
        writefile(library.directory .. "/configs/" .. config_name .. ".cfg", config_data)
        
        -- Обновляем список конфигураций
        library:config_list_update()
        
        -- Показываем уведомление
        library:notification{
            text = "Configuration saved: " .. config_name,
            time = 3
        }
    end
}

config_sections.configs:button{
    name = "Load Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        
        -- Проверяем, существует ли файл
        if isfile(library.directory .. "/configs/" .. config_name .. ".cfg") then
            -- Загружаем конфигурацию из файла
            local config_data = readfile(library.directory .. "/configs/" .. config_name .. ".cfg")
            library:load_config(config_data)
            
            -- Показываем уведомление
            library:notification{
                text = "Configuration loaded: " .. config_name,
                time = 3
            }
        else
            -- Показываем уведомление об ошибке
            library:notification{
                text = "Error: Configuration not found",
                time = 3
            }
        end
    end
}

-- Добавляем dropdown для выбора сохраненных конфигураций
local config_dropdown = config_sections.configs:dropdown{
    name = "Saved Configurations",
    flag = "config_dropdown",
    options = {},
    callback = function(selected)
        library.flags["config_name"] = selected
    end
}

-- Сохраняем ссылку на dropdown для обновления списка конфигураций
library.config_holder = config_dropdown

-- Обновляем список конфигураций при загрузке
library:config_list_update()

config_sections.configs:button{
    name = "Delete Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        
        -- Проверяем, существует ли файл
        if isfile(library.directory .. "/configs/" .. config_name .. ".cfg") then
            -- Удаляем файл
            delfile(library.directory .. "/configs/" .. config_name .. ".cfg")
            
            -- Обновляем список конфигураций
            library:config_list_update()
            
            -- Показываем уведомление
            library:notification{
                text = "Configuration deleted: " .. config_name,
                time = 3
            }
        else
            -- Показываем уведомление об ошибке
            library:notification{
                text = "Error: Configuration not found",
                time = 3
            }
        end
    end
}

-- Настройка секции меню
config_sections.menu:colorpicker{
    name = "Accent Color",
    flag = "accent_color",
    default = Color3.fromRGB(100, 100, 255), -- Цвет по умолчанию
    callback = function(color)
        library:update_theme("accent", color)
    end
}

config_sections.menu:toggle{
    name = "Watermark",
    flag = "watermark_enabled",
    default = false, -- По умолчанию выключено
    callback = function(state)
        -- Используем нашу собственную функцию
        watermark.toggle(state)
    end
}

config_sections.menu:keybind{
    name = "Menu Toggle Key",
    flag = "menu_toggle_key",
    default = Enum.KeyCode.Insert, -- Insert по умолчанию
    mode = "toggle",
    callback = function(state)
        win.set_menu_visibility(state)
    end
}

-- Создаем обработчик для клавиши переключения меню
library:connection(game:GetService("UserInputService").InputBegan, function(input, gameProcessed)
    if gameProcessed then return end
    
    local menu_key = library.flags["menu_toggle_key"]
    if menu_key and input.KeyCode == menu_key then
        local current_state = not win:IsVisible()
        win.set_menu_visibility(current_state)
    end
end)

-- Отображаем уведомление о загрузке скрипта
library:notification{
    text = "Script successfully loaded!",
    time = 3
}

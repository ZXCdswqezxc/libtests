loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))()
-- ac bypass, dont touch
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/ZXCdswqezxc/libtests/refs/heads/main/library"))()

-- Создание кастомной ватермарки
local watermark = {}

do
    -- Функция для форматирования даты
    local function get_date_text()
        local date = os.date("*t")
        return string.format("replace.gg | %02d.%02d.%d %02d:%02d:%02d", 
            date.day, date.month, date.year, date.hour, date.min, date.sec)
    end

    -- Создаем элементы UI для ватермарки
    local holder = library:create("Frame", {
        Parent = library.gui,
        Name = "CustomWatermark",
        BackgroundTransparency = 1,
        Position = UDim2.new(0, 20, 0, 20),
        BorderColor3 = Color3.fromRGB(19, 19, 19),
        ZIndex = 2,
        AutomaticSize = Enum.AutomaticSize.X,
        BackgroundColor3 = Color3.fromRGB(40, 40, 40),
        Visible = false -- По умолчанию скрыто
    })
    
    local inline1 = library:create("Frame", {
        Parent = holder,
        Name = "",
        Active = true, 
        Draggable = true, 
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(0, 250, 0, 40), -- Увеличил размер для отображения полной даты
        BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    })
    
    local accent_line = library:create("Frame", {
        Parent = inline1,
        Name = "",
        BorderColor3 = Color3.fromRGB(34, 34, 34),
        Size = UDim2.new(1, 0, 0, 2),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    })

    -- Подключаем акцентный цвет к теме
    library:apply_theme(accent_line, "accent", "BackgroundColor3") 
    
    local depth = library:create("Frame", {
        Parent = inline1,
        Name = "",
        BackgroundTransparency = 0.5,
        Position = UDim2.new(0, 0, 0, 1),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(1, 0, 0, 1),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    })
    
    local inline2 = library:create("Frame", {
        Parent = inline1,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(1, -4, 1, -4),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(26, 26, 26)
    })
    
    local main = library:create("Frame", {
        Parent = inline2,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(57, 57, 57),
        Size = UDim2.new(1, -4, 1, -4),
        BackgroundColor3 = Color3.fromRGB(26, 26, 26)
    })
    
    local tab_inline = library:create("Frame", {
        Parent = main,
        Name = "",
        Position = UDim2.new(0, 6, 0, 6),
        BorderColor3 = Color3.fromRGB(19, 19, 19),
        Size = UDim2.new(1, -12, 1, -12),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(19, 19, 19)
    })
    
    local tabs = library:create("Frame", {
        Parent = tab_inline,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(56, 56, 56),
        Size = UDim2.new(1, -4, 1, -4),
        BackgroundColor3 = Color3.fromRGB(22, 22, 22)
    })
    
    local name_label = library:create("TextLabel", {
        Parent = tabs,
        Name = "",
        FontFace = library.font,
        TextColor3 = Color3.fromRGB(100, 100, 255), -- Цвет акцента по умолчанию
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Text = get_date_text(),
        TextStrokeTransparency = 0.5,
        Size = UDim2.new(0, 0, 1, 0),
        Position = UDim2.new(0, 8, 0, 0),
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
        BorderSizePixel = 0,
        AutomaticSize = Enum.AutomaticSize.X,
        TextSize = 12,
        BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    })
    
    -- Подключаем цвет текста к акцентному цвету
    library:apply_theme(name_label, "accent", "TextColor3")
    
    local padding = library:create("UIPadding", {
        Parent = tabs,
        Name = "",
        PaddingRight = UDim.new(0, 21)
    })
    
    local glow = library:create("ImageLabel", {
        Parent = accent_line,
        Name = "",
        ImageColor3 = Color3.fromRGB(100, 100, 255),
        ScaleType = Enum.ScaleType.Slice,
        ImageTransparency = 0.8999999761581421,
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        Image = "http://www.roblox.com/asset/?id=18245826428",
        BackgroundTransparency = 1,
        Position = UDim2.new(0, -20, 0, -20),
        Size = UDim2.new(1, 40, 0, 42),
        ZIndex = 2,
        BorderSizePixel = 0,
        SliceCenter = Rect.new(Vector2.new(21, 21), Vector2.new(79, 79))
    })

    -- Подключаем свечение к акцентному цвету
    library:apply_theme(glow, "accent", "ImageColor3")
    
    -- Функционал ватермарки
    watermark = {
        holder = holder,
        
        -- Функция для переключения видимости
        toggle = function(state)
            holder.Visible = state
            
            -- Если включаем ватермарку, сразу обновляем текст даты
            if state then
                watermark.update_date()
            end
        end,
        
        -- Функция для обновления текста
        update_text = function(text)
            name_label.Text = text
            -- Обновляем размер для нового текста
            inline1.Size = UDim2.new(0, ((#text / 2) * 5) + 100, 0, 40)
        end,
        
        -- Функция для обновления даты
        update_date = function()
            watermark.update_text(get_date_text())
        end
    }
    
    -- Запускаем таймер для обновления даты (каждую секунду)
    task.spawn(function()
        while true do
            task.wait(1) -- Обновляем дату каждую секунду
            
            -- Обновляем только если ватермарка видима
            if holder.Visible then
                watermark.update_date()
            end
        end
    end)
end

-- Создаём окно с 6 вкладками
local win = library:window{
    name = "replace.gg",
}

-- Скрываем все UI элементы при запуске
win.toggle_watermark(false)    -- Скрываем встроенный водяной знак
win.toggle_list(false)         -- Скрываем список привязок клавиш
win.toggle_playerlist(false)   -- Скрываем список игроков

local tabs = {
    Combat = win:tab{name = "Combat"},
    Movement = win:tab{name = "Movement"},
    Visuals = win:tab{name = "Visuals"},
    Misc = win:tab{name = "Misc"},
    Config = win:tab{name = "Config"}
}

-- Добавляем секции в Misc вкладку
local misc_sections = {
    camera = tabs.Misc:section{name = "Camera", side = "left"},
    extras = tabs.Misc:section{name = "Extras", side = "right"}
}

-- Anti-AFK переменная и логика
local antiAFK = {
    Enabled = false,
    VirtualUser = game:GetService("VirtualUser")
}

game:GetService("Players").LocalPlayer.Idled:Connect(function()
    if antiAFK.Enabled then
        antiAFK.VirtualUser:CaptureController()
        antiAFK.VirtualUser:ClickButton2(Vector2.new())
        print("Anti-AFK prevented kick")
    end
end)

-- Добавляем toggle для Infinity Zoom
misc_sections.camera:toggle{
    name = "Infinity Zoom",
    flag = "infinity_zoom",
    default = false,
    callback = function(state)
        if state then
            game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
        else
            -- Возвращаем стандартное значение при отключении
            game.Players.LocalPlayer.CameraMaxZoomDistance = 128
        end
    end
}

-- Добавляем toggle для Anti-AFK
misc_sections.extras:toggle{
    name = "Anti-AFK",
    flag = "anti_afk",
    default = false,
    callback = function(state)
        antiAFK.Enabled = state
    end
}

-- Disable Shadows
local disableShadows = {
    Enabled = false,
    Thread = nil
}

local function remove_shadows()
    local lighting = game:GetService("Lighting")
    lighting.GlobalShadows = false
    -- Удаляем объекты типа Shadow, если есть
    for _, obj in ipairs(lighting:GetDescendants()) do
        if obj:IsA("Shadow") or obj.Name:lower():find("shadow") then
            pcall(function() obj:Destroy() end)
        end
    end
end

misc_sections.extras:toggle{
    name = "Disable Shadows",
    flag = "disable_shadows",
    default = false,
    callback = function(state)
        disableShadows.Enabled = state
        if state then
            remove_shadows()
            disableShadows.Thread = task.spawn(function()
                while disableShadows.Enabled do
                    task.wait(5)
                    remove_shadows()
                end
            end)
        else
            disableShadows.Enabled = false
            -- Возвращаем тени обратно
            local lighting = game:GetService("Lighting")
            lighting.GlobalShadows = true
        end
    end
}

-- NoJumpCD
local noJumpCD = {
    Enabled = false
}

-- NoRecoil
local noRecoil = {
    Enabled = false
}

-- Глобальный хук для NoJumpCD (ставим только один раз)
do
    local old_newindex = nil
    old_newindex = hookmetamethod(game, "__newindex", function(self, Index, Value)
        -- NoJumpCD: блокируем изменение JumpPower только если включено
        if noJumpCD.Enabled and not checkcaller() and game.IsA(self, "Humanoid") and Index == "JumpPower" then
            return
        end
        -- NoRecoil: блокируем изменение CFrame камеры только если включено
        if noRecoil.Enabled then
            local callingScr = getcallingscript()
            local function isframework(scriptInstance)
                return tostring(scriptInstance) == "Framework"
            end
            local function checkArgs(instance, index)
                return tostring(instance):lower():find("camera") and tostring(index) == "CFrame"
            end
            if isframework(callingScr) and checkArgs(self, Index) then
                return -- просто блокируем, не вызываем old_newindex!
            end
        end
        return old_newindex(self, Index, Value)
    end)
end

misc_sections.extras:toggle{
    name = "NoJumpCD",
    flag = "no_jump_cd",
    default = false,
    callback = function(state)
        noJumpCD.Enabled = state
    end
}

misc_sections.extras:toggle{
    name = "NoRecoil",
    flag = "no_recoil",
    default = false,
    callback = function(state)
        noRecoil.Enabled = state
    end
}

-- AntiFling
local antiFling = {
    Enabled = false,
    Connections = {},
    LastPosition = nil,
    Players = {}, -- Кэш для отслеживаемых игроков
    CheckFrequency = 0.1 -- Проверять 10 раз в секунду вместо каждого кадра
}

-- Функция для создания уведомления
local function showNotification(text, color)
    library:notification{
        text = text,
        time = 3
    }
    -- Также отправляем в чат, если возможно
    pcall(function()
        game.StarterGui:SetCore("ChatMakeSystemMessage", {
            Text = text,
            Color = color or Color3.fromRGB(255, 200, 0)
        })
    end)
end

misc_sections.extras:toggle{
    name = "Anti-Fling",
    flag = "anti_fling",
    default = false,
    callback = function(state)
        antiFling.Enabled = state
        
        if state then
            -- Очищаем старые соединения, если они есть
            for _, connection in pairs(antiFling.Connections) do
                if connection and connection.Connected then
                    connection:Disconnect()
                end
            end
            antiFling.Connections = {}
            antiFling.Players = {}
            
            -- Получаем сервисы (кэшируем один раз)
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local LocalPlayer = Players.LocalPlayer
            
            -- Функция для добавления игрока в отслеживание
            local function addPlayerToTracking(player)
                if player == LocalPlayer then return end
                
                -- Создаем запись для игрока
                antiFling.Players[player] = {
                    Character = player.Character,
                    PrimaryPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart"),
                    Detected = false
                }
                
                -- Подключаемся к событию появления персонажа
                local charConnection = player.CharacterAdded:Connect(function(newChar)
                    if not antiFling.Enabled then return end
                    
                    -- Обновляем данные игрока
                    antiFling.Players[player] = antiFling.Players[player] or {}
                    antiFling.Players[player].Character = newChar
                    antiFling.Players[player].Detected = false
                    
                    -- Ждем появления HumanoidRootPart
                    task.spawn(function()
                        local hrp = newChar:WaitForChild("HumanoidRootPart", 3)
                        if hrp and antiFling.Enabled and antiFling.Players[player] then
                            antiFling.Players[player].PrimaryPart = hrp
                        end
                    end)
                end)
                
                table.insert(antiFling.Connections, charConnection)
            end
            
            -- Добавляем существующих игроков
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    addPlayerToTracking(player)
                end
            end
            
            -- Подключаемся к новым игрокам
            local playerAddedConnection = Players.PlayerAdded:Connect(function(player)
                if not antiFling.Enabled then return end
                addPlayerToTracking(player)
            end)
            
            -- Обрабатываем удаление игроков
            local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
                if antiFling.Players[player] then
                    antiFling.Players[player] = nil
                end
            end)
            
            table.insert(antiFling.Connections, playerAddedConnection)
            table.insert(antiFling.Connections, playerRemovingConnection)
            
            -- ОДИН Heartbeat для всех проверок с ограниченной частотой
            local lastCheckTime = 0
            local mainHeartbeatConnection = RunService.Heartbeat:Connect(function()
                if not antiFling.Enabled then return end
                
                -- Ограничиваем частоту проверок
                local currentTime = tick()
                if currentTime - lastCheckTime < antiFling.CheckFrequency then
                    return
                end
                lastCheckTime = currentTime
                
                -- 1. Проверяем других игроков на флинг
                for player, data in pairs(antiFling.Players) do
                    if player and player.Parent and data.Character and data.Character.Parent and data.PrimaryPart and data.PrimaryPart.Parent then
                        -- Проверяем скорость
                        if data.PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 or data.PrimaryPart.AssemblyLinearVelocity.Magnitude > 100 then
                            if not data.Detected then
                                showNotification("Fling Exploit detected, Player: " .. tostring(player), Color3.fromRGB(255, 200, 0))
                                data.Detected = true
                            end
                            
                            -- Отключаем коллизии только для частей с высокой скоростью
                            for _, part in ipairs(data.Character:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    part.CanCollide = false
                                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                    part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                                end
                            end
                        end
                    end
                end
                
                -- 2. Защита локального игрока (только если персонаж существует)
                pcall(function()
                    local character = LocalPlayer.Character
                    if character and character.Parent then
                        local primaryPart = character.PrimaryPart
                        if primaryPart and primaryPart.Parent then
                            if primaryPart.AssemblyLinearVelocity.Magnitude > 250 or primaryPart.AssemblyAngularVelocity.Magnitude > 250 then
                                primaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                primaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                
                                if antiFling.LastPosition then
                                    primaryPart.CFrame = antiFling.LastPosition
                                end
                                
                                showNotification("Fling attempt detected! Neutralizing velocity.", Color3.fromRGB(255, 0, 0))
                            elseif primaryPart.AssemblyLinearVelocity.Magnitude < 50 then
                                antiFling.LastPosition = primaryPart.CFrame
                            end
                        end
                    end
                end)
            end)
            
            table.insert(antiFling.Connections, mainHeartbeatConnection)
            
            showNotification("Anti-Fling enabled", Color3.fromRGB(0, 255, 0))
        else
            -- Отключаем все соединения
            for _, connection in pairs(antiFling.Connections) do
                if connection and connection.Connected then
                    connection:Disconnect()
                end
            end
            antiFling.Connections = {}
            antiFling.Players = {}
            antiFling.LastPosition = nil
            
            showNotification("Anti-Fling disabled", Color3.fromRGB(255, 0, 0))
        end
    end
}

-- Добавляем секции в Config вкладку
local config_sections = {
    configs = tabs.Config:section{name = "Configurations", side = "left"},
    menu = tabs.Config:section{name = "Menu Settings", side = "right"}
}

-- Настройка секции конфигураций
config_sections.configs:textbox{
    name = "Configuration Name",
    flag = "config_name",
    placeholder = "default",
    clear_on_focus = false,
    default = "default"
}

config_sections.configs:button{
    name = "Save Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        local config_data = library:get_config()
        
        -- Сохранение в файл
        writefile(library.directory .. "/configs/" .. config_name .. ".cfg", config_data)
        
        -- Обновляем список конфигураций
        library:config_list_update()
        
        -- Показываем уведомление
        library:notification{
            text = "Configuration saved: " .. config_name,
            time = 3
        }
    end
}

config_sections.configs:button{
    name = "Load Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        
        -- Проверяем, существует ли файл
        if isfile(library.directory .. "/configs/" .. config_name .. ".cfg") then
            -- Загружаем конфигурацию из файла
            local config_data = readfile(library.directory .. "/configs/" .. config_name .. ".cfg")
            library:load_config(config_data)
            
            -- Показываем уведомление
            library:notification{
                text = "Configuration loaded: " .. config_name,
                time = 3
            }
        else
            -- Показываем уведомление об ошибке
            library:notification{
                text = "Error: Configuration not found",
                time = 3
            }
        end
    end
}

-- Добавляем dropdown для выбора сохраненных конфигураций
local config_dropdown = config_sections.configs:dropdown{
    name = "Saved Configurations",
    flag = "config_dropdown",
    options = {},
    callback = function(selected)
        library.flags["config_name"] = selected
    end
}

-- Сохраняем ссылку на dropdown для обновления списка конфигураций
library.config_holder = config_dropdown

-- Обновляем список конфигураций при загрузке
library:config_list_update()

config_sections.configs:button{
    name = "Delete Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        
        -- Проверяем, существует ли файл
        if isfile(library.directory .. "/configs/" .. config_name .. ".cfg") then
            -- Удаляем файл
            delfile(library.directory .. "/configs/" .. config_name .. ".cfg")
            
            -- Обновляем список конфигураций
            library:config_list_update()
            
            -- Показываем уведомление
            library:notification{
                text = "Configuration deleted: " .. config_name,
                time = 3
            }
        else
            -- Показываем уведомление об ошибке
            library:notification{
                text = "Error: Configuration not found",
                time = 3
            }
        end
    end
}

-- Настройка секции меню
config_sections.menu:colorpicker{
    name = "Accent Color",
    flag = "accent_color",
    default = Color3.fromRGB(100, 100, 255), -- Цвет по умолчанию
    callback = function(color)
        library:update_theme("accent", color)
    end
}

config_sections.menu:toggle{
    name = "Watermark",
    flag = "watermark_enabled",
    default = false, -- По умолчанию выключено
    callback = function(state)
        -- Используем нашу собственную функцию
        watermark.toggle(state)
    end
}

config_sections.menu:keybind{
    name = "Menu Toggle Key",
    flag = "menu_toggle_key",
    default = Enum.KeyCode.Insert, -- Insert по умолчанию
    mode = "toggle",
    callback = function(state)
        win.set_menu_visibility(state)
    end
}

-- Создаем обработчик для клавиши переключения меню
library:connection(game:GetService("UserInputService").InputBegan, function(input, gameProcessed)
    if gameProcessed then return end
    
    local menu_key = library.flags["menu_toggle_key"]
    if menu_key and input.KeyCode == menu_key then
        local current_state = not win:IsVisible()
        win.set_menu_visibility(current_state)
    end
end)

-- Отображаем уведомление о загрузке скрипта
library:notification{
    text = "Script successfully loaded!",
    time = 3
}

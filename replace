wait(3)
loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))()
-- ac bypass, dont touch
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/ZXCdswqezxc/libtests/refs/heads/main/library"))()

-- Создание кастомной ватермарки
local watermark = {}

do
    -- Функция для форматирования даты
    local function get_date_text()
        local date = os.date("*t")
        return string.format("replace.gg | %02d.%02d.%d %02d:%02d:%02d", 
            date.day, date.month, date.year, date.hour, date.min, date.sec)
    end

    -- Создаем элементы UI для ватермарки
    local holder = library:create("Frame", {
        Parent = library.gui,
        Name = "CustomWatermark",
        BackgroundTransparency = 1,
        Position = UDim2.new(0, 20, 0, 20),
        BorderColor3 = Color3.fromRGB(19, 19, 19),
        ZIndex = 2,
        AutomaticSize = Enum.AutomaticSize.X,
        BackgroundColor3 = Color3.fromRGB(40, 40, 40),
        Visible = false -- По умолчанию скрыто
    })
    
    local inline1 = library:create("Frame", {
        Parent = holder,
        Name = "",
        Active = true, 
        Draggable = true, 
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(0, 250, 0, 40), -- Увеличил размер для отображения полной даты
        BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    })
    
    local accent_line = library:create("Frame", {
        Parent = inline1,
        Name = "",
        BorderColor3 = Color3.fromRGB(34, 34, 34),
        Size = UDim2.new(1, 0, 0, 2),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    })

    -- Подключаем акцентный цвет к теме
    library:apply_theme(accent_line, "accent", "BackgroundColor3") 
    
    local depth = library:create("Frame", {
        Parent = inline1,
        Name = "",
        BackgroundTransparency = 0.5,
        Position = UDim2.new(0, 0, 0, 1),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(1, 0, 0, 1),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    })
    
    local inline2 = library:create("Frame", {
        Parent = inline1,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Size = UDim2.new(1, -4, 1, -4),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(26, 26, 26)
    })
    
    local main = library:create("Frame", {
        Parent = inline2,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(57, 57, 57),
        Size = UDim2.new(1, -4, 1, -4),
        BackgroundColor3 = Color3.fromRGB(26, 26, 26)
    })
    
    local tab_inline = library:create("Frame", {
        Parent = main,
        Name = "",
        Position = UDim2.new(0, 6, 0, 6),
        BorderColor3 = Color3.fromRGB(19, 19, 19),
        Size = UDim2.new(1, -12, 1, -12),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(19, 19, 19)
    })
    
    local tabs = library:create("Frame", {
        Parent = tab_inline,
        Name = "",
        Position = UDim2.new(0, 2, 0, 2),
        BorderColor3 = Color3.fromRGB(56, 56, 56),
        Size = UDim2.new(1, -4, 1, -4),
        BackgroundColor3 = Color3.fromRGB(22, 22, 22)
    })
    
    local name_label = library:create("TextLabel", {
        Parent = tabs,
        Name = "",
        FontFace = library.font,
        TextColor3 = Color3.fromRGB(100, 100, 255), -- Цвет акцента по умолчанию
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        Text = get_date_text(),
        TextStrokeTransparency = 0.5,
        Size = UDim2.new(0, 0, 1, 0),
        Position = UDim2.new(0, 8, 0, 0),
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
        BorderSizePixel = 0,
        AutomaticSize = Enum.AutomaticSize.X,
        TextSize = 12,
        BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    })
    
    -- Подключаем цвет текста к акцентному цвету
    library:apply_theme(name_label, "accent", "TextColor3")
    
    local padding = library:create("UIPadding", {
        Parent = tabs,
        Name = "",
        PaddingRight = UDim.new(0, 21)
    })
    
    local glow = library:create("ImageLabel", {
        Parent = accent_line,
        Name = "",
        ImageColor3 = Color3.fromRGB(100, 100, 255),
        ScaleType = Enum.ScaleType.Slice,
        ImageTransparency = 0.8999999761581421,
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        Image = "http://www.roblox.com/asset/?id=18245826428",
        BackgroundTransparency = 1,
        Position = UDim2.new(0, -20, 0, -20),
        Size = UDim2.new(1, 40, 0, 42),
        ZIndex = 2,
        BorderSizePixel = 0,
        SliceCenter = Rect.new(Vector2.new(21, 21), Vector2.new(79, 79))
    })

    -- Подключаем свечение к акцентному цвету
    library:apply_theme(glow, "accent", "ImageColor3")
    
    -- Функционал ватермарки
    watermark = {
        holder = holder,
        
        -- Функция для переключения видимости
        toggle = function(state)
            holder.Visible = state
            
            -- Если включаем ватермарку, сразу обновляем текст даты
            if state then
                watermark.update_date()
            end
        end,
        
        -- Функция для обновления текста
        update_text = function(text)
            name_label.Text = text
            -- Обновляем размер для нового текста
            inline1.Size = UDim2.new(0, ((#text / 2) * 5) + 100, 0, 40)
        end,
        
        -- Функция для обновления даты
        update_date = function()
            watermark.update_text(get_date_text())
        end
    }
    
    -- Запускаем таймер для обновления даты (каждую секунду)
    task.spawn(function()
        while task.wait(1) do -- Оптимизация: объединяем wait с циклом
            -- Обновляем только если ватермарка видима
            if holder.Visible then
                watermark.update_date()
            end
        end
    end)
end

-- Создаём окно с 6 вкладками
local win = library:window{
    name = "replace.gg",
}

-- Скрываем все UI элементы при запуске
win.toggle_watermark(false)    -- Скрываем встроенный водяной знак
win.toggle_list(false)         -- Скрываем список привязок клавиш
win.toggle_playerlist(false)   -- Скрываем список игроков

local tabs = {
    Combat = win:tab{name = "Combat"},
    Movement = win:tab{name = "Movement"},
    Visuals = win:tab{name = "Visuals"},
    Misc = win:tab{name = "Misc"},
    Config = win:tab{name = "Config"}
}

-- Добавляем секции в Movement вкладку
local movement_sections = {
    main = tabs.Movement:section{name = "Main", side = "left"},
    extra = tabs.Movement:section{name = "Extra", side = "right"},
    speed = tabs.Movement:section{name = "Speed", side = "left"}
}

-- Создаем переменные для Speed Hack
local speedHack = {
    Enabled = false,
    Active = false,
    Connection = nil,
    CharConnection = nil
}

-- Настройки спидхака
getgenv().cframespeedtoggle = false -- Флаг активации спидхака
getgenv().speedvalue = 0 -- Скорость (0 = стандартная, 1000 = заметное ускорение)
getgenv().speedStep = 0.002 -- Шаг прироста скорости на единицу speedvalue (фиксированное значение)

-- Функция для отключения всех соединений спидхака
local function disconnectSpeedHack()
    if speedHack.Connection and speedHack.Connection.Connected then
        speedHack.Connection:Disconnect()
        speedHack.Connection = nil
    end
    
    if speedHack.CharConnection and speedHack.CharConnection.Connected then
        speedHack.CharConnection:Disconnect()
        speedHack.CharConnection = nil
    end
end

-- Функция для настройки Speed Hack
local function setupSpeedHack()
    -- Проверяем, включена ли функция
    if not speedHack.Enabled then return end
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    
    -- Удаление ненужных скриптов из персонажа
    if LocalPlayer.Character then
        for _, v in pairs(LocalPlayer.Character:GetChildren()) do
            if v:IsA("Script") and v.Name ~= "Health" and v.Name ~= "Sound" and v:FindFirstChild("LocalScript") then
                v:Destroy()
            end
        end
    end
    
    -- Отключаем предыдущие соединения для экономии ресурсов
    disconnectSpeedHack()
    
    -- Обработка добавления нового персонажа
    speedHack.CharConnection = LocalPlayer.CharacterAdded:Connect(function(char)
        repeat task.wait() until LocalPlayer.Character -- Ждем, пока персонаж загрузится
        
        char.ChildAdded:Connect(function(child)
            if child:IsA("Script") and child:FindFirstChild("LocalScript") then
                task.wait(0.1) -- Небольшая задержка для стабильности
                child.LocalScript:FireServer()
            end
        end)
    end)
    
    -- Основной цикл спидхака
    speedHack.Connection = RunService.Heartbeat:Connect(function()
        if speedHack.Enabled and speedHack.Active and LocalPlayer.Character and 
           LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and
           LocalPlayer.Character:FindFirstChild("Humanoid") then
            
            local humanoidRootPart = LocalPlayer.Character.HumanoidRootPart
            local moveDirection = LocalPlayer.Character.Humanoid.MoveDirection
            
            -- Линейное масштабирование скорости: speedvalue * speedStep
            local speedMultiplier = getgenv().speedvalue * getgenv().speedStep
            
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + (moveDirection * speedMultiplier)
        end
    end)
end

-- Добавляем toggle для Speed Hack (мастер-переключатель)
movement_sections.speed:toggle{
    name = "Speed Hack",
    flag = "speed_hack_enabled",
    default = false,
    callback = function(state)
        speedHack.Enabled = state
        
        if state then
            setupSpeedHack()
            library:notification{
                text = "Speed Hack enabled (Press keybind to activate)",
                time = 3
            }
        else
            speedHack.Active = false
            getgenv().cframespeedtoggle = false
            disconnectSpeedHack()
            
            library:notification{
                text = "Speed Hack disabled",
                time = 3
            }
        end
    end
}

-- Добавляем textbox для настройки скорости
movement_sections.speed:textbox{
    name = "Speed Value",
    flag = "speed_value",
    placeholder = "1000",
    default = "1000",
    clear_on_focus = true,
    callback = function(text)
        -- Проверяем, что введено число
        local number = tonumber(text)
        if number and number >= 0 then
            getgenv().speedvalue = number
            library:notification{
                text = "Speed set to " .. number,
                time = 3
            }
        else
            library:notification{
                text = "Please enter a valid number",
                time = 3
            }
        end
    end
}

-- Добавляем keybind для переключения активности Speed Hack
movement_sections.speed:keybind{
    name = "Speed Toggle Key",
    flag = "speed_toggle_key",
    default = Enum.KeyCode.X,
    mode = "toggle",
    callback = function(state)
        if not speedHack.Enabled then
            library:notification{
                text = "Enable Speed Hack first!",
                time = 3
            }
            return
        end
        
        speedHack.Active = state
        getgenv().cframespeedtoggle = state
        
        if state then
            library:notification{
                text = "Speed Hack: ACTIVE",
                time = 3
            }
        else
            library:notification{
                text = "Speed Hack: INACTIVE",
                time = 3
            }
        end
    end
}

-- AntiGround функционал
getgenv().antigroundtoggle = false -- По умолчанию выключено
getgenv().yoffset = 5 -- Минимальная высота над землёй (в studs)

-- Создаем переменные для AntiGround
local antiGround = {
    Enabled = false,
    Connection = nil,
    CharConnection = nil,
    LastCheck = 0,
    CheckFrequency = 0.02 -- 50 раз в секунду вместо каждого кадра
}

-- Функция для настройки AntiGround
local function setupAntiGround()
    -- Проверяем, включена ли функция
    if not antiGround.Enabled then return end
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer

    local RAYCAST_DISTANCE = 50 -- Максимальная длина луча для поиска земли
    local RAYCAST_PARAMS = RaycastParams.new()
    RAYCAST_PARAMS.FilterType = Enum.RaycastFilterType.Blacklist
    
    if LocalPlayer.Character then
        RAYCAST_PARAMS.FilterDescendantsInstances = {LocalPlayer.Character}
    end

    -- Функция для получения позиции над землёй
    local function getGroundPosition()
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return nil
        end

        local rootPart = LocalPlayer.Character.HumanoidRootPart
        local origin = rootPart.Position
        local direction = Vector3.new(0, -RAYCAST_DISTANCE, 0)
        local raycastResult = workspace:Raycast(origin, direction, RAYCAST_PARAMS)

        if raycastResult then
            return raycastResult.Position + Vector3.new(0, getgenv().yoffset, 0)
        end
        return nil
    end

    -- Отключение коллизии персонажа
    local function disableCollisions()
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end

    -- Очистка скриптов
    if LocalPlayer.Character then
        for _, v in pairs(LocalPlayer.Character:GetChildren()) do
            if v:IsA("Script") and v.Name ~= "Health" and v.Name ~= "Sound" and v:FindFirstChild("LocalScript") then
                v:Destroy()
            end
        end
        disableCollisions()
    end

    -- Отключаем предыдущее соединение CharacterAdded, если оно существует
    if antiGround.CharConnection and antiGround.CharConnection.Connected then
        antiGround.CharConnection:Disconnect()
        antiGround.CharConnection = nil
    end

    -- Обработка появления нового персонажа
    antiGround.CharConnection = LocalPlayer.CharacterAdded:Connect(function(char)
        repeat
            task.wait()
        until LocalPlayer.Character
        
        RAYCAST_PARAMS.FilterDescendantsInstances = {char}
        
        local humanoid = char:WaitForChild("Humanoid")
        char:WaitForChild("HumanoidRootPart")
        
        disableCollisions()
        
        char.ChildAdded:Connect(function(child)
            if child:IsA("Script") then 
                task.wait(0.1)
                if child:FindFirstChild("LocalScript") then
                    child.LocalScript:FireServer()
                end
            end
        end)
    end)

    -- Отключаем предыдущее соединение Heartbeat, если оно существует
    if antiGround.Connection and antiGround.Connection.Connected then
        antiGround.Connection:Disconnect()
        antiGround.Connection = nil
    end

    -- Сохраняем последнюю позицию для плавности
    local lastPosition = nil
    local lastGroundY = nil
    
    -- Основной цикл обновления с ограничением частоты
    antiGround.Connection = RunService.Heartbeat:Connect(function(deltaTime)
        -- Проверяем, включен ли AntiGround
        if not getgenv().antigroundtoggle then return end
        
        -- Ограничиваем частоту обновлений для снижения нагрузки
        local currentTime = tick()
        if currentTime - antiGround.LastCheck < antiGround.CheckFrequency then
            return
        end
        antiGround.LastCheck = currentTime
        
        if LocalPlayer.Character and 
           LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and 
           LocalPlayer.Character:FindFirstChild("Humanoid") then
            
            local humanoid = LocalPlayer.Character.Humanoid
            local rootPart = LocalPlayer.Character.HumanoidRootPart
            local groundPosition = getGroundPosition()

            if groundPosition then
                -- Устанавливаем состояние "бег" для анимаций ходьбы
                if humanoid.MoveDirection.Magnitude > 0 then
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                else
                    humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
                end

                -- Получаем текущую позицию и направление
                local currentCFrame = rootPart.CFrame
                local moveDirection = humanoid.MoveDirection * 0.3 -- Скорость ~17 Velocity

                -- Стабилизация Y-позиции для предотвращения тряски
                local targetY = groundPosition.Y
                local currentY = currentCFrame.Y
                local newY = currentY
                
                -- Инициализируем lastGroundY при первом запуске
                if not lastGroundY then
                    lastGroundY = targetY
                end
                
                -- Сглаживание изменений высоты земли для предотвращения тряски
                lastGroundY = lastGroundY + (targetY - lastGroundY) * 0.1
                
                -- Плавная интерполяция высоты
                if currentY < lastGroundY then
                    -- Быстрее поднимаемся, если под нами земля
                    newY = currentY + (lastGroundY - currentY) * 0.2
                elseif currentY > lastGroundY + 0.5 then
                    -- Медленнее опускаемся, если мы выше земли
                    newY = currentY - (currentY - lastGroundY) * 0.05
                else
                    -- Стабилизируем на нужной высоте
                    newY = lastGroundY
                end

                -- Новая позиция с плавным движением
                local newPosition = Vector3.new(
                    currentCFrame.X + moveDirection.X,
                    newY,
                    currentCFrame.Z + moveDirection.Z
                )

                -- Сохраняем последнюю позицию для дополнительной плавности
                if not lastPosition then
                    lastPosition = newPosition
                else
                    -- Дополнительное сглаживание позиции
                    newPosition = Vector3.new(
                        lastPosition.X + (newPosition.X - lastPosition.X) * 0.7,
                        newPosition.Y,
                        lastPosition.Z + (newPosition.Z - lastPosition.Z) * 0.7
                    )
                    lastPosition = newPosition
                end

                -- Применяем CFrame, сохраняя ориентацию
                rootPart.CFrame = CFrame.new(newPosition) * CFrame.Angles(currentCFrame:ToEulerAnglesXYZ())

                -- Отключаем гравитацию и стабилизируем скорость
                rootPart.Velocity = Vector3.new(
                    rootPart.Velocity.X * 0.8, 
                    0, 
                    rootPart.Velocity.Z * 0.8
                )
            end
        end
    end)
end

-- Добавляем toggle для AntiGround
movement_sections.main:toggle{
    name = "AntiGround",
    flag = "antiground_enabled",
    default = false,
    callback = function(state)
        getgenv().antigroundtoggle = state
        antiGround.Enabled = state
        
        if state then
            setupAntiGround()
            library:notification{
                text = "AntiGround enabled",
                time = 3
            }
        else
            -- Отключаем соединения при выключении
            if antiGround.Connection and antiGround.Connection.Connected then
                antiGround.Connection:Disconnect()
                antiGround.Connection = nil
            end
            
            if antiGround.CharConnection and antiGround.CharConnection.Connected then
                antiGround.CharConnection:Disconnect()
                antiGround.CharConnection = nil
            end
            
            library:notification{
                text = "AntiGround disabled",
                time = 3
            }
        end
    end
}

-- Добавляем слайдер для настройки высоты над землей
movement_sections.main:slider{
    name = "Ground Distance",
    flag = "ground_distance",
    min = 5,
    max = 20,
    default = 5,
    increment = 0.5,
    callback = function(value)
        getgenv().yoffset = value
        library:notification{
            text = "Ground distance set to " .. value,
            time = 3
        }
    end
}

-- Добавляем секции в Misc вкладку
local misc_sections = {
    camera = tabs.Misc:section{name = "Camera", side = "left"},
    extras = tabs.Misc:section{name = "Extras", side = "right"}
}

-- Функция для удаления всех сидений в игре
local function removeAllSeats()
    local removedCount = 0
    
    -- Проверяем все объекты в рабочем пространстве
    for _, obj in pairs(game:GetDescendants()) do
        -- Ищем объекты типа Seat, VehicleSeat, и т.д.
        if obj:IsA("Seat") or obj:IsA("VehicleSeat") or obj:IsA("Platform") or 
           (obj:IsA("Part") and obj.Name:lower():find("seat")) then
            pcall(function()
                obj.Parent = nil -- Удаляем объект из иерархии
                removedCount = removedCount + 1
            end)
        end
    end
    
    -- Возвращаем количество удаленных объектов
    return removedCount
end

-- Добавляем кнопку для удаления сидений
misc_sections.extras:button{
    name = "Remove All Seats",
    callback = function()
        local count = removeAllSeats()
        library:notification{
            text = "Removed " .. count .. " seats from the game",
            time = 3
        }
    end
}

-- Anti-AFK переменная и логика
local antiAFK = {
    Enabled = false,
    VirtualUser = game:GetService("VirtualUser")
}

game:GetService("Players").LocalPlayer.Idled:Connect(function()
    if antiAFK.Enabled then
        antiAFK.VirtualUser:CaptureController()
        antiAFK.VirtualUser:ClickButton2(Vector2.new())
        print("Anti-AFK prevented kick")
    end
end)

-- Добавляем toggle для Infinity Zoom
misc_sections.camera:toggle{
    name = "Infinity Zoom",
    flag = "infinity_zoom",
    default = false,
    callback = function(state)
        if state then
            game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
            library:notification{
                text = "Infinity Zoom enabled",
                time = 3
            }
        else
            game.Players.LocalPlayer.CameraMaxZoomDistance = 128
            library:notification{
                text = "Infinity Zoom disabled",
                time = 3
            }
        end
    end
}

-- Добавляем toggle для Anti-AFK
misc_sections.extras:toggle{
    name = "Anti-AFK",
    flag = "anti_afk",
    default = false,
    callback = function(state)
        antiAFK.Enabled = state
        if state then
            library:notification{
                text = "Anti-AFK enabled",
                time = 3
            }
        else
            library:notification{
                text = "Anti-AFK disabled",
                time = 3
            }
        end
    end
}

-- Disable Shadows
local disableShadows = {
    Enabled = false,
    Thread = nil
}

local function remove_shadows()
    local lighting = game:GetService("Lighting")
    lighting.GlobalShadows = false
    -- Удаляем объекты типа Shadow, если есть
    for _, obj in ipairs(lighting:GetDescendants()) do
        if obj:IsA("Shadow") or obj.Name:lower():find("shadow") then
            pcall(function() obj:Destroy() end)
        end
    end
end

misc_sections.extras:toggle{
    name = "Disable Shadows",
    flag = "disable_shadows",
    default = false,
    callback = function(state)
        disableShadows.Enabled = state
        if state then
            remove_shadows()
            -- Останавливаем предыдущий поток, если он существует
            if disableShadows.Thread then
                task.cancel(disableShadows.Thread)
                disableShadows.Thread = nil
            end
            
            disableShadows.Thread = task.spawn(function()
                while disableShadows.Enabled do
                    task.wait(5)
                    -- Дополнительная проверка на случай, если toggle был выключен
                    if not disableShadows.Enabled then break end
                    remove_shadows()
                end
            end)
            library:notification{
                text = "Shadows disabled",
                time = 3
            }
        else
            -- Останавливаем поток
            if disableShadows.Thread then
                task.cancel(disableShadows.Thread)
                disableShadows.Thread = nil
            end
            
            disableShadows.Enabled = false
            local lighting = game:GetService("Lighting")
            lighting.GlobalShadows = true
            library:notification{
                text = "Shadows enabled",
                time = 3
            }
        end
    end
}

-- NoJumpCD
local noJumpCD = {
    Enabled = false
}

-- NoRecoil
local noRecoil = {
    Enabled = false
}

-- Глобальный хук для NoJumpCD (ставим только один раз)
do
    local old_newindex = nil
    old_newindex = hookmetamethod(game, "__newindex", function(self, Index, Value)
        -- NoJumpCD: блокируем изменение JumpPower только если включено
        if noJumpCD.Enabled and not checkcaller() and game.IsA(self, "Humanoid") and Index == "JumpPower" then
            return
        end
        -- NoRecoil: блокируем изменение CFrame камеры только если включено
        if noRecoil.Enabled then
            local callingScr = getcallingscript()
            local function isframework(scriptInstance)
                return tostring(scriptInstance) == "Framework"
            end
            local function checkArgs(instance, index)
                return tostring(instance):lower():find("camera") and tostring(index) == "CFrame"
            end
            if isframework(callingScr) and checkArgs(self, Index) then
                return -- просто блокируем, не вызываем old_newindex!
            end
        end
        return old_newindex(self, Index, Value)
    end)
end

misc_sections.extras:toggle{
    name = "NoJumpCD",
    flag = "no_jump_cd",
    default = false,
    callback = function(state)
        noJumpCD.Enabled = state
        if state then
            library:notification{
                text = "NoJumpCD enabled",
                time = 3
            }
        else
            library:notification{
                text = "NoJumpCD disabled",
                time = 3
            }
        end
    end
}

misc_sections.extras:toggle{
    name = "NoRecoil",
    flag = "no_recoil",
    default = false,
    callback = function(state)
        noRecoil.Enabled = state
        if state then
            library:notification{
                text = "NoRecoil enabled",
                time = 3
            }
        else
            library:notification{
                text = "NoRecoil disabled",
                time = 3
            }
        end
    end
}

-- AntiFling
local antiFling = {
    Enabled = false,
    Connections = {},
    LastPosition = nil,
    Players = {}, -- Кэш для отслеживаемых игроков
    CheckFrequency = 0.1 -- Проверять 10 раз в секунду вместо каждого кадра
}

misc_sections.extras:toggle{
    name = "Anti-Fling",
    flag = "anti_fling",
    default = false,
    callback = function(state)
        antiFling.Enabled = state
        
        if state then
            -- Очищаем старые соединения, если они есть
            for _, connection in pairs(antiFling.Connections) do
                if connection and connection.Connected then
                    connection:Disconnect()
                end
            end
            antiFling.Connections = {}
            antiFling.Players = {}
            
            -- Получаем сервисы (кэшируем один раз)
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local LocalPlayer = Players.LocalPlayer
            
            -- Функция для добавления игрока в отслеживание
            local function addPlayerToTracking(player)
                if player == LocalPlayer then return end
                
                -- Создаем запись для игрока
                antiFling.Players[player] = {
                    Character = player.Character,
                    PrimaryPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart"),
                    Detected = false
                }
                
                -- Подключаемся к событию появления персонажа
                local charConnection = player.CharacterAdded:Connect(function(newChar)
                    if not antiFling.Enabled then return end
                    
                    -- Обновляем данные игрока
                    antiFling.Players[player] = antiFling.Players[player] or {}
                    antiFling.Players[player].Character = newChar
                    antiFling.Players[player].Detected = false
                    
                    -- Ждем появления HumanoidRootPart
                    task.spawn(function()
                        local hrp = newChar:WaitForChild("HumanoidRootPart", 3)
                        if hrp and antiFling.Enabled and antiFling.Players[player] then
                            antiFling.Players[player].PrimaryPart = hrp
                        end
                    end)
                end)
                
                table.insert(antiFling.Connections, charConnection)
            end
            
            -- Добавляем существующих игроков
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    addPlayerToTracking(player)
                end
            end
            
            -- Подключаемся к новым игрокам
            local playerAddedConnection = Players.PlayerAdded:Connect(function(player)
                if not antiFling.Enabled then return end
                addPlayerToTracking(player)
            end)
            
            -- Обрабатываем удаление игроков
            local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
                if antiFling.Players[player] then
                    antiFling.Players[player] = nil
                end
            end)
            
            table.insert(antiFling.Connections, playerAddedConnection)
            table.insert(antiFling.Connections, playerRemovingConnection)
            
            -- ОДИН Heartbeat для всех проверок с ограниченной частотой
            local lastCheckTime = 0
            local mainHeartbeatConnection = RunService.Heartbeat:Connect(function()
                if not antiFling.Enabled then return end
                
                -- Ограничиваем частоту проверок
                local currentTime = tick()
                if currentTime - lastCheckTime < antiFling.CheckFrequency then
                    return
                end
                lastCheckTime = currentTime
                
                -- 1. Проверяем других игроков на флинг
                for player, data in pairs(antiFling.Players) do
                    if player and player.Parent and data.Character and data.Character.Parent and data.PrimaryPart and data.PrimaryPart.Parent then
                        -- Проверяем скорость
                        if data.PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 or data.PrimaryPart.AssemblyLinearVelocity.Magnitude > 100 then
                            if not data.Detected then
                                library:notification{
                                    text = "Fling Exploit detected, Player: " .. tostring(player),
                                    time = 3
                                }
                                -- Также отправляем в чат, если возможно
                                pcall(function()
                                    game.StarterGui:SetCore("ChatMakeSystemMessage", {
                                        Text = "Fling Exploit detected, Player: " .. tostring(player),
                                        Color = Color3.fromRGB(255, 200, 0)
                                    })
                                end)
                                data.Detected = true
                            end
                            
                            -- Отключаем коллизии только для частей с высокой скоростью
                            for _, part in ipairs(data.Character:GetDescendants()) do
                                if part:IsA("BasePart") then
                                    part.CanCollide = false
                                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                    part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                                end
                            end
                        end
                    end
                end
                
                -- 2. Защита локального игрока (только если персонаж существует)
                pcall(function()
                    local character = LocalPlayer.Character
                    if character and character.Parent then
                        local primaryPart = character.PrimaryPart
                        if primaryPart and primaryPart.Parent then
                            if primaryPart.AssemblyLinearVelocity.Magnitude > 250 or primaryPart.AssemblyAngularVelocity.Magnitude > 250 then
                                primaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                primaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                
                                if antiFling.LastPosition then
                                    primaryPart.CFrame = antiFling.LastPosition
                                end
                                
                                library:notification{
                                    text = "Fling attempt detected! Neutralizing velocity.",
                                    time = 3
                                }
                                -- Также отправляем в чат, если возможно
                                pcall(function()
                                    game.StarterGui:SetCore("ChatMakeSystemMessage", {
                                        Text = "Fling attempt detected! Neutralizing velocity.",
                                        Color = Color3.fromRGB(255, 0, 0)
                                    })
                                end)
                            elseif primaryPart.AssemblyLinearVelocity.Magnitude < 50 then
                                antiFling.LastPosition = primaryPart.CFrame
                            end
                        end
                    end
                end)
            end)
            
            table.insert(antiFling.Connections, mainHeartbeatConnection)
            
            library:notification{
                text = "Anti-Fling enabled",
                time = 3
            }
        else
            -- Отключаем все соединения
            for _, connection in pairs(antiFling.Connections) do
                if connection and connection.Connected then
                    connection:Disconnect()
                end
            end
            antiFling.Connections = {}
            antiFling.Players = {}
            antiFling.LastPosition = nil
            
            library:notification{
                text = "Anti-Fling disabled",
                time = 3
            }
        end
    end
}

-- Destroy Cheaters (Finobe)
getgenv().Finobe1 = false
local destroyCheaters = {
    Enabled = false, -- мастер-тумблер
    Active = false,  -- активность (переключается кейбиндом)
    Finobe2 = nil,
    Connections = {},
    HookFunction = nil
}

local LocalFinobe = game:GetService("Players").LocalPlayer
local Runfinobe = game:GetService("RunService")
local InputService = game:GetService("UserInputService")
local NewCFrame = CFrame.new

-- Отключаем все соединения Destroy Cheaters
local function disconnectDestroyCheaters()
    for _, connection in pairs(destroyCheaters.Connections) do
        if connection and connection.Connected then
            connection:Disconnect()
        end
    end
    destroyCheaters.Connections = {}
end

-- Функция для настройки Destroy Cheaters
local function setupDestroyCheaters()
    -- Отключаем предыдущие соединения
    disconnectDestroyCheaters()
    
    -- Heartbeat для телепортации
    local heartbeatConn = Runfinobe.Heartbeat:Connect(function()
        if not destroyCheaters.Enabled or not destroyCheaters.Active then return end
        if LocalFinobe.Character and LocalFinobe.Character:FindFirstChild("HumanoidRootPart") then
            local FinobeChar = LocalFinobe.Character.HumanoidRootPart
            local Offset = FinobeChar.CFrame * NewCFrame(9e9, 0/0, math.huge)
            destroyCheaters.Finobe2 = FinobeChar.CFrame
            FinobeChar.CFrame = Offset
        end
    end)
    
    -- RenderStepped для возврата (отдельное соединение для лучшей синхронизации)
    local renderConn = Runfinobe.RenderStepped:Connect(function()
        if not destroyCheaters.Enabled or not destroyCheaters.Active then return end
        if LocalFinobe.Character and LocalFinobe.Character:FindFirstChild("HumanoidRootPart") and destroyCheaters.Finobe2 then
            LocalFinobe.Character.HumanoidRootPart.CFrame = destroyCheaters.Finobe2
        end
    end)
    
    table.insert(destroyCheaters.Connections, heartbeatConn)
    table.insert(destroyCheaters.Connections, renderConn)
end

-- Инициализация первого соединения (будет заменено при включении функции)
setupDestroyCheaters()

-- Хук для маскировки
if not destroyCheaters.HookFunction then
    local oldHook
    oldHook = hookmetamethod(game, "__index", newcclosure(function(self, key)
        if not checkcaller() then
            if key == "CFrame" and destroyCheaters.Enabled and destroyCheaters.Active and LocalFinobe.Character and LocalFinobe.Character:FindFirstChild("HumanoidRootPart") and LocalFinobe.Character:FindFirstChild("Humanoid") and LocalFinobe.Character:FindFirstChild("Humanoid").Health > 0 then
                if self == LocalFinobe.Character.HumanoidRootPart and destroyCheaters.Finobe2 ~= nil then
                    return destroyCheaters.Finobe2
                end
            end
        end
        return oldHook(self, key)
    end))
    destroyCheaters.HookFunction = oldHook
end

-- Toggle Destroy Cheaters (мастер-тумблер)
local destroyCheaterToggle = misc_sections.extras:toggle{
    name = "Destroy Cheaters",
    flag = "destroy_cheaters",
    default = false,
    callback = function(state)
        destroyCheaters.Enabled = state
        if not state then
            destroyCheaters.Active = false
            getgenv().Finobe1 = false
            
            -- Отключаем все соединения для экономии ресурсов
            disconnectDestroyCheaters()
            
            if destroyCheaters.Finobe2 and LocalFinobe.Character and LocalFinobe.Character:FindFirstChild("HumanoidRootPart") then
                pcall(function()
                    LocalFinobe.Character.HumanoidRootPart.CFrame = destroyCheaters.Finobe2
                end)
            end
            library:notification{
                text = "Destroy Cheaters disabled",
                time = 3
            }
        else
            -- Настраиваем соединения
            setupDestroyCheaters()
            
            library:notification{
                text = "Destroy Cheaters enabled",
                time = 3
            }
        end
    end
}

-- Keybind для Destroy Cheaters (работает только если тумблер включён)
misc_sections.extras:keybind{
    name = "Destroy Cheaters Key",
    flag = "destroy_cheaters_key",
    default = Enum.KeyCode.X,
    mode = "toggle",
    callback = function()
        if not destroyCheaters.Enabled then
            library:notification{
                text = "Enable Destroy Cheaters first!",
                time = 3
            }
            return
        end
        destroyCheaters.Active = not destroyCheaters.Active
        getgenv().Finobe1 = destroyCheaters.Active
        if destroyCheaters.Active then
            library:notification{
                text = "Destroy Cheaters: ACTIVE",
                time = 3
            }
        else
            if destroyCheaters.Finobe2 and LocalFinobe.Character and LocalFinobe.Character:FindFirstChild("HumanoidRootPart") then
                pcall(function()
                    LocalFinobe.Character.HumanoidRootPart.CFrame = destroyCheaters.Finobe2
                end)
            end
            library:notification{
                text = "Destroy Cheaters: INACTIVE",
                time = 3
            }
        end
    end
}

-- Добавляем секции в Config вкладку
local config_sections = {
    configs = tabs.Config:section{name = "Configurations", side = "left"},
    menu = tabs.Config:section{name = "Menu Settings", side = "right"}
}

-- Настройка секции конфигураций
config_sections.configs:textbox{
    name = "Configuration Name",
    flag = "config_name",
    placeholder = "default",
    clear_on_focus = false,
    default = "default"
}

config_sections.configs:button{
    name = "Save Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        local config_data = library:get_config()
        
        -- Сохранение в файл
        writefile(library.directory .. "/configs/" .. config_name .. ".cfg", config_data)
        
        -- Обновляем список конфигураций
        library:config_list_update()
        
        -- Показываем уведомление
        library:notification{
            text = "Configuration saved: " .. config_name,
            time = 3
        }
    end
}

config_sections.configs:button{
    name = "Load Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        
        -- Проверяем, существует ли файл
        if isfile(library.directory .. "/configs/" .. config_name .. ".cfg") then
            -- Загружаем конфигурацию из файла
            local config_data = readfile(library.directory .. "/configs/" .. config_name .. ".cfg")
            library:load_config(config_data)
            
            -- Показываем уведомление
            library:notification{
                text = "Configuration loaded: " .. config_name,
                time = 3
            }
        else
            -- Показываем уведомление об ошибке
            library:notification{
                text = "Error: Configuration not found",
                time = 3
            }
        end
    end
}

-- Добавляем dropdown для выбора сохраненных конфигураций
local config_dropdown = config_sections.configs:dropdown{
    name = "Saved Configurations",
    flag = "config_dropdown",
    options = {},
    callback = function(selected)
        library.flags["config_name"] = selected
    end
}

-- Сохраняем ссылку на dropdown для обновления списка конфигураций
library.config_holder = config_dropdown

-- Обновляем список конфигураций при загрузке
library:config_list_update()

config_sections.configs:button{
    name = "Delete Configuration",
    callback = function()
        local config_name = library.flags["config_name"] or "default"
        
        -- Проверяем, существует ли файл
        if isfile(library.directory .. "/configs/" .. config_name .. ".cfg") then
            -- Удаляем файл
            delfile(library.directory .. "/configs/" .. config_name .. ".cfg")
            
            -- Обновляем список конфигураций
            library:config_list_update()
            
            -- Показываем уведомление
            library:notification{
                text = "Configuration deleted: " .. config_name,
                time = 3
            }
        else
            -- Показываем уведомление об ошибке
            library:notification{
                text = "Error: Configuration not found",
                time = 3
            }
        end
    end
}

-- Настройка секции меню
config_sections.menu:colorpicker{
    name = "Accent Color",
    flag = "accent_color",
    default = Color3.fromRGB(100, 100, 255), -- Цвет по умолчанию
    callback = function(color)
        library:update_theme("accent", color)
    end
}

config_sections.menu:toggle{
    name = "Watermark",
    flag = "watermark_enabled",
    default = false, -- По умолчанию выключено
    callback = function(state)
        watermark.toggle(state)
        if state then
            library:notification{
                text = "Watermark enabled",
                time = 3
            }
        else
            library:notification{
                text = "Watermark disabled",
                time = 3
            }
        end
    end
}

config_sections.menu:keybind{
    name = "Menu Toggle Key",
    flag = "menu_toggle_key",
    default = Enum.KeyCode.Insert, -- Insert по умолчанию
    mode = "toggle",
    callback = function(state)
        win.set_menu_visibility(state)
    end
}

-- Создаем обработчик для клавиши переключения меню
local menuToggleConnection = nil
menuToggleConnection = library:connection(game:GetService("UserInputService").InputBegan, function(input, gameProcessed)
    if gameProcessed then return end
    
    local menu_key = library.flags["menu_toggle_key"]
    if menu_key and input.KeyCode == menu_key then
        local current_state = not win:IsVisible()
        win.set_menu_visibility(current_state)
    end
end)

-- Функция для очистки ресурсов при выходе из игры
game:GetService("Players").LocalPlayer.OnTeleport:Connect(function()
    -- Отключаем все соединения
    if menuToggleConnection and menuToggleConnection.Connected then
        menuToggleConnection:Disconnect()
    end
    
    -- Отключаем все функции
    antiAFK.Enabled = false
    
    -- Отключаем DisableShadows
    disableShadows.Enabled = false
    if disableShadows.Thread then
        task.cancel(disableShadows.Thread)
        disableShadows.Thread = nil
    end
    
    -- Отключаем NoJumpCD и NoRecoil
    noJumpCD.Enabled = false
    noRecoil.Enabled = false
    
    -- Отключаем SpeedHack
    speedHack.Enabled = false
    speedHack.Active = false
    getgenv().cframespeedtoggle = false
    disconnectSpeedHack()
    
    -- Отключаем AntiGround
    antiGround.Enabled = false
    getgenv().antigroundtoggle = false
    if antiGround.Connection and antiGround.Connection.Connected then
        antiGround.Connection:Disconnect()
        antiGround.Connection = nil
    end
    if antiGround.CharConnection and antiGround.CharConnection.Connected then
        antiGround.CharConnection:Disconnect()
        antiGround.CharConnection = nil
    end
    
    -- Отключаем AntiFling
    antiFling.Enabled = false
    for _, connection in pairs(antiFling.Connections) do
        if connection and connection.Connected then
            connection:Disconnect()
        end
    end
    antiFling.Connections = {}
    
    -- Отключаем Destroy Cheaters
    destroyCheaters.Enabled = false
    destroyCheaters.Active = false
    getgenv().Finobe1 = false
    disconnectDestroyCheaters()
end)

-- Отображаем уведомление о загрузке скрипта
library:notification{
    text = "Replace.gg loaded",
    time = 3
}

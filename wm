local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Create the main window
local Window = Library:CreateWindow({
    Title = "TitanCX",
    Footer = "Cursed by 32vision",
    ShowCustomCursor = false,
})

-- Create tabs
local Tabs = {
    Combat = Window:AddTab("Combat", "sword"),
    Movement = Window:AddTab("Movement", "move"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Misc = Window:AddTab("Misc", "box"),
    Other = Window:AddTab("Other", "list"),
    HUD = Window:AddTab("HUD", "monitor"),
}

-- Setup ThemeManager and SaveManager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("ClickGUI")
SaveManager:SetFolder("ClickGUI/settings")

SaveManager:BuildConfigSection(Tabs["HUD"])
ThemeManager:ApplyToTab(Tabs["HUD"])

-- Silent Aim Configuration
local SilentAimConfig = {
	Enabled = true, -- Master switch (изменено обратно на true)
	Keybind = Enum.KeyCode.Q, -- Key to select or deselect target
	AimPart = "HumanoidRootPart", -- Default aim part
	MultipleParts = {
		Enabled = false,
		Parts = { "Head", "UpperTorso", "HumanoidRootPart", "LowerTorso" }
	},
	Prediction = {
		Enabled = true, -- Включено предсказание
		Type = "CFrame", -- Resolver modes: Vel, MoveDir, CFrame, Velmodded
		PredictionXZ = 0, -- Horizontal prediction factor (for non-Velmodded resolvers)
		PredictionY = 0, -- Vertical prediction factor (for non-Velmodded resolvers)
		Velmodded = {
			ResolverRefresh = 2, -- Refresh rate in milliseconds for Velmodded resolver (more frequent updates)
			PredictionFactor = 0 -- Scaling factor for Velmodded predicted velocity
		}
	},
	Offsets = {
		Jump = 0, -- Y offset for jumping targets
		Fall = 0  -- Y offset for falling targets
	},
	Checks = {
		WallCheck = false, -- Check for obstructions
		TargetDeath = false, -- Stop aiming if target dies
		ResetTargetOnLocalDeath = false, -- Reset target when local player dies
		KOCheck = false, -- Check if target is knocked out
		GrabbedCheck = false -- Check if target is grabbed
	},
	BulletTP = {
		Enabled = false, -- Simple on/off toggle
	}
}

-- AutoStomp Configuration
local AutoStompConfig = {
	Enabled = false, -- Master switch for AutoStomp
	StompCount = 20, -- Number of stomps to perform
	StompInterval = 0.099, -- Time between stomps in seconds
	YOffset = 2, -- Vertical offset for stomping position
	Visualizer = {
		Enabled = true, -- Enable visual indicator
		Color = Color3.fromRGB(255, 0, 0), -- Red color
		Transparency = 0.3, -- 30% transparency
		Size = Vector3.new(5, 15, 5) -- Size of visualizer (увеличено в 10 раз)
	},
	Text = {
		PrimaryColor = Color3.fromRGB(255, 0, 0), -- Первый цвет (красный)
		SecondaryColor = Color3.fromRGB(255, 255, 0), -- Второй цвет (желтый)
		BlinkSpeed = 0.5 -- Скорость мигания в секундах
	}
}

-- Add UI elements for Combat/Aimbot
local AimbotGroup = Tabs.Combat:AddLeftGroupbox("Aimbot")

-- Main toggle
local AimbotToggle = AimbotGroup:AddToggle("AimbotEnabled", {
    Text = "Enable",
    Default = true,
    Tooltip = "Toggle aimbot",
    Callback = function(Value)
        SilentAimConfig.Enabled = Value
    end
})

-- Keybind
local AimbotKey = AimbotToggle:AddKeyPicker("AimbotKey", {
    Default = "Q",
    SyncToggleState = false,
    Mode = "Toggle",
    Text = "Lock Key",
    Callback = function(Value)
        -- Проверяем тип данных для предотвращения ошибки
        if type(Value) == "table" and Value.Name then
            -- Сохраняем значение кнопки как строку для UI и как Enum.KeyCode для обработчика
            local keyCode = Value.Name
            SilentAimConfig.KeybindName = keyCode -- Храним строковое представление
            SilentAimConfig.Keybind = Enum.KeyCode[keyCode] -- Преобразуем в Enum.KeyCode
            
            Library:Notify("Key set to " .. keyCode, 1.5)
        end
    end
})

-- Target part
local TargetPartDropdown = AimbotGroup:AddDropdown("TargetPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = SilentAimConfig.AimPart,
    Text = "Target Part",
    Tooltip = "Body part to aim at",
    Callback = function(Value)
        SilentAimConfig.AimPart = Value
    end
})

-- Prediction settings
local PredictionToggle = AimbotGroup:AddToggle("PredictionEnabled", {
    Text = "Prediction",
    Default = true,
    Tooltip = "Predict movement",
    Callback = function(Value)
        SilentAimConfig.Prediction.Enabled = Value
    end
})

local PredictionTypeDropdown = AimbotGroup:AddDropdown("PredictionType", {
    Values = {"Vel", "MoveDir", "CFrame", "Velmodded"},
    Default = SilentAimConfig.Prediction.Type,
    Text = "Method",
    Tooltip = "Prediction calculation method",
    Callback = function(Value)
        SilentAimConfig.Prediction.Type = Value
    end
})

-- Replace XZPredictionSlider with Input
local XZPredictionInput = AimbotGroup:AddInput("PredictionXZ", {
    Text = "XZ Factor",
    Default = tostring(SilentAimConfig.Prediction.PredictionXZ),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Horizontal prediction",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.PredictionXZ = num
            Library:Notify("XZ set to " .. num, 1.5)
        end
    end
})

-- Replace YPredictionSlider with Input
local YPredictionInput = AimbotGroup:AddInput("PredictionY", {
    Text = "Y Factor",
    Default = tostring(SilentAimConfig.Prediction.PredictionY),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Vertical prediction",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.PredictionY = num
            Library:Notify("Y set to " .. num, 1.5)
        end
    end
})

-- Velmodded settings
local VelmoddedGroup = Tabs.Combat:AddRightGroupbox("Advanced")

local ResolverRefreshSlider = VelmoddedGroup:AddSlider("ResolverRefresh", {
    Text = "Refresh",
    Default = SilentAimConfig.Prediction.Velmodded.ResolverRefresh,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Suffix = "ms",
    Callback = function(Value)
        SilentAimConfig.Prediction.Velmodded.ResolverRefresh = Value
    end
})

-- Replace PredictionFactorSlider with Input
local PredictionFactorInput = VelmoddedGroup:AddInput("PredictionFactor", {
    Text = "Factor",
    Default = tostring(SilentAimConfig.Prediction.Velmodded.PredictionFactor),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Prediction multiplier",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.Velmodded.PredictionFactor = num
            Library:Notify("Factor set to " .. num, 1.5)
        end
    end
})

-- Offset settings
local OffsetGroup = Tabs.Combat:AddRightGroupbox("Offsets")

local JumpOffsetSlider = OffsetGroup:AddSlider("JumpOffset", {
    Text = "Jump",
    Default = SilentAimConfig.Offsets.Jump,
    Min = -5,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        SilentAimConfig.Offsets.Jump = Value
    end
})

local FallOffsetSlider = OffsetGroup:AddSlider("FallOffset", {
    Text = "Fall",
    Default = SilentAimConfig.Offsets.Fall,
    Min = -5,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        SilentAimConfig.Offsets.Fall = Value
    end
})

-- Checks
local ChecksGroup = Tabs.Combat:AddLeftGroupbox("Checks")

local WallCheckToggle = ChecksGroup:AddToggle("WallCheck", {
    Text = "Visibility",
    Default = SilentAimConfig.Checks.WallCheck,
    Tooltip = "Target must be visible",
    Callback = function(Value)
        SilentAimConfig.Checks.WallCheck = Value
    end
})

local TargetDeathToggle = ChecksGroup:AddToggle("TargetDeath", {
    Text = "Target Death",
    Default = SilentAimConfig.Checks.TargetDeath,
    Tooltip = "Reset on target death",
    Callback = function(Value)
        SilentAimConfig.Checks.TargetDeath = Value
    end
})

local ResetOnDeathToggle = ChecksGroup:AddToggle("ResetOnDeath", {
    Text = "Local Death",
    Default = SilentAimConfig.Checks.ResetTargetOnLocalDeath,
    Tooltip = "Reset when you die",
    Callback = function(Value)
        SilentAimConfig.Checks.ResetTargetOnLocalDeath = Value
    end
})

-- Add KO Check and Grabbed Check to Checks group
local KOCheckToggle = ChecksGroup:AddToggle("KOCheck", {
    Text = "K.O. Check",
    Default = SilentAimConfig.Checks.KOCheck,
    Tooltip = "Skip KO'd targets",
    Callback = function(Value)
        SilentAimConfig.Checks.KOCheck = Value
    end
})

local GrabbedCheckToggle = ChecksGroup:AddToggle("GrabbedCheck", {
    Text = "Grabbed Check",
    Default = SilentAimConfig.Checks.GrabbedCheck,
    Tooltip = "Skip grabbed targets",
    Callback = function(Value)
        SilentAimConfig.Checks.GrabbedCheck = Value
    end
})

-- Add Extra group with AutoStomp
local ExtraGroup = Tabs.Combat:AddRightGroupbox("Extra")

-- Add BulletTP group
local BulletTPGroup = Tabs.Combat:AddLeftGroupbox("Bullet TP")

-- Main toggle
local BulletTPToggle = BulletTPGroup:AddToggle("BulletTPEnabled", {
    Text = "Enable",
    Default = SilentAimConfig.BulletTP.Enabled,
    Tooltip = "Teleport bullets to aimbot target (uses same prediction settings as aimbot)",
    Callback = function(Value)
        SilentAimConfig.BulletTP.Enabled = Value
        Library:Notify("Bullet TP " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- Add Keybind to BulletTP toggle
local BulletTPKey = BulletTPToggle:AddKeyPicker("BulletTPKey", {
    Default = "C",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Toggle Key",
    Callback = function(Value)
        SilentAimConfig.BulletTP.Enabled = Value
        Library:Notify("Bullet TP " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- AutoStomp UI
local AutoStompToggle = ExtraGroup:AddToggle("AutoStompEnabled", {
    Text = "Auto Stomp",
    Default = AutoStompConfig.Enabled,
    Tooltip = "Automatically stomp KO'd targets",
    Callback = function(Value)
        AutoStompConfig.Enabled = Value
        Library:Notify("Auto Stomp " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

local StompCountSlider = ExtraGroup:AddSlider("StompCount", {
    Text = "Stomp Count",
    Default = AutoStompConfig.StompCount,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Callback = function(Value)
        AutoStompConfig.StompCount = Value
    end
})

local StompIntervalInput = ExtraGroup:AddInput("StompInterval", {
    Text = "Interval",
    Default = tostring(AutoStompConfig.StompInterval),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Time between stomps",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            AutoStompConfig.StompInterval = num
            Library:Notify("Interval set to " .. num, 1.5)
        end
    end
})

local YOffsetSlider = ExtraGroup:AddSlider("YOffset", {
    Text = "Y Offset",
    Default = AutoStompConfig.YOffset,
    Min = 0,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        AutoStompConfig.YOffset = Value
    end
})

-- Visualizer settings
local VisualizerToggle = ExtraGroup:AddToggle("VisualizerEnabled", {
    Text = "Visualizer",
    Default = AutoStompConfig.Visualizer.Enabled,
    Tooltip = "Show desync position",
    Callback = function(Value)
        AutoStompConfig.Visualizer.Enabled = Value
        
        -- Update active visualizer if desync is currently running
        if autoStompState.activeState then
            if Value and not autoStompState.visualizer then
                autoStompState.visualizer = createVisualizer()
            elseif not Value and autoStompState.visualizer then
                autoStompState.visualizer:Destroy()
                autoStompState.visualizer = nil
            end
        end
    end
})

-- Box color
local BoxColorPicker = VisualizerToggle:AddColorPicker("VisualizerColorR", {
    Default = AutoStompConfig.Visualizer.Color,
    Title = "Box Color",
    Callback = function(Value)
        AutoStompConfig.Visualizer.Color = Value
        
        -- Update active visualizer if it exists
        if autoStompState.visualizer then
            autoStompState.visualizer.Color = Value
        end
    end
})

-- Text primary color
local PrimaryColorPicker = VisualizerToggle:AddColorPicker("PrimaryColorPicker", {
    Default = AutoStompConfig.Text.PrimaryColor,
    Title = "Text Color 1",
    Callback = function(Value)
        AutoStompConfig.Text.PrimaryColor = Value
    end
})

-- Text secondary color
local SecondaryColorPicker = VisualizerToggle:AddColorPicker("SecondaryColorPicker", {
    Default = AutoStompConfig.Text.SecondaryColor, 
    Title = "Text Color 2",
    Callback = function(Value)
        AutoStompConfig.Text.SecondaryColor = Value
    end
})

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Optimization Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local BotsFolder = Workspace:FindFirstChild("Bots") or Instance.new("Folder", Workspace)
local Inf = math.huge

-- State Variables
local selectedTarget = nil -- Currently selected target (player or bot)
local lastPosition = nil -- For resolver calculations
local lastUpdateTime = nil -- For resolver timing
local predictedPosition = nil -- Predicted target position
local velmoddedState = { -- Velmodded resolver state
	target = nil,
	last_position = nil,
	last_refresh = tick(),
	target_velocity = Vector3.zero
}

-- AutoStomp state variables
local autoStompState = {
    activeState = false, -- Active state (is desync and stomp being performed)
    followPart = nil, -- Part for camera to follow during desync
    stompCounter = 0, -- Current stomp count
    lastStompTime = nil, -- Last time a stomp was performed
    visualizer = nil, -- Visual indicator for desync position
    stompingText = nil, -- Text label to show "STOMPING"
    lastTextBlink = 0 -- Timer for text blinking effect
}

-- Entity state table (players and bots)
local entityStates = {} -- Tracks isTarget for each entity (player or bot)

-- Prevent multiple executions
if getgenv().Loaded then
	return
end
getgenv().Loaded = true

-- Check if target is knocked out and not grabbed
local function checkKOState(entity)
    if not entity or not entity:IsA("Player") or not entity.Character then
        return false
    end
    
    local bodyEffects = entity.Character:FindFirstChild("BodyEffects")
    if not bodyEffects then
        return false
    end
    
    local ko = bodyEffects:FindFirstChild("K.O")
    local isGrabbed = entity.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    
    return ko and ko.Value and not isGrabbed
end

-- AutoStomp functions
local function createFollowPart()
    local part = Instance.new("Part")
    part.Name = "FollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Parent = Workspace
    return part
end

local function createVisualizer()
    if not AutoStompConfig.Visualizer.Enabled then
        return nil
    end
    
    local visualizer = Instance.new("Part")
    visualizer.Name = "DesyncVisualizer"
    visualizer.Anchored = true
    visualizer.CanCollide = false
    visualizer.Material = Enum.Material.ForceField
    visualizer.Size = AutoStompConfig.Visualizer.Size
    visualizer.Color = AutoStompConfig.Visualizer.Color
    visualizer.Transparency = AutoStompConfig.Visualizer.Transparency
    visualizer.Parent = Workspace
    return visualizer
end

-- Функция для создания текста "STOMPING"
local function createStompingText()
    -- Создаем BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "StompingLabel"
    billboardGui.Size = UDim2.new(0, 200, 0, 50)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Размещаем над целью
    billboardGui.AlwaysOnTop = true
    billboardGui.LightInfluence = 0
    billboardGui.MaxDistance = 100
    billboardGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Для видимости через стены
    
    -- Устанавливаем пометку "AlwaysOnTop" для видимости через стены
    local humanoidRootPart = Workspace.CurrentCamera
    if humanoidRootPart then
        billboardGui.Adornee = humanoidRootPart
    end
    
    -- Создаем текстовую метку
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = AutoStompConfig.Text.PrimaryColor
    textLabel.TextStrokeTransparency = 0 -- Черная обводка
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    textLabel.TextSize = 30
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Text = "STOMPING"
    textLabel.TextScaled = true
    textLabel.ZIndex = 10 -- Высокий Z-Index для отображения поверх других объектов
    textLabel.Parent = billboardGui
    
    return billboardGui
end

local function setupDesync()
    if autoStompState.activeState then return end
    autoStompState.activeState = true
    autoStompState.followPart = createFollowPart()
    autoStompState.visualizer = createVisualizer()
    autoStompState.stompCounter = AutoStompConfig.StompCount
    autoStompState.lastStompTime = tick()
    
    -- Создаем текстовую метку и прикрепляем к цели
    if selectedTarget and selectedTarget:IsA("Player") and selectedTarget.Character then
        autoStompState.stompingText = createStompingText()
        
        -- Размещаем метку в пространстве
        autoStompState.stompingText.Parent = game.CoreGui -- Для видимости через стены
        
        -- Точка привязки для позиционирования
        local targetPart = selectedTarget.Character:FindFirstChild("UpperTorso") or 
                          selectedTarget.Character:FindFirstChild("Torso") or 
                          selectedTarget.Character:FindFirstChild("HumanoidRootPart")
        
        if targetPart then
            autoStompState.stompingText.Adornee = targetPart
        else
            autoStompState.stompingText.Adornee = Workspace.CurrentCamera
        end
    end
    
    Library:Notify("Desync activated", 1)
end

local function cleanupDesync()
    if not autoStompState.activeState then return end
    autoStompState.activeState = false
    
    if autoStompState.followPart then
        autoStompState.followPart:Destroy()
        autoStompState.followPart = nil
    end
    
    if autoStompState.visualizer then
        autoStompState.visualizer:Destroy()
        autoStompState.visualizer = nil
    end
    
    if autoStompState.stompingText then
        autoStompState.stompingText:Destroy()
        autoStompState.stompingText = nil
    end
    
    autoStompState.stompCounter = 0
    autoStompState.lastStompTime = nil
    Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    
    Library:Notify("Desync deactivated", 1)
end

local function performStomp()
    ReplicatedStorage.MainEvent:FireServer("Stomp")
    if ReplicatedStorage:FindFirstChild("assets") and ReplicatedStorage.assets:FindFirstChild("dh") then
        ReplicatedStorage.assets.dh.MainEvent:FireServer("Stomp")
    end
    autoStompState.stompCounter = autoStompState.stompCounter - 1
    autoStompState.lastStompTime = tick()
    if autoStompState.stompCounter <= 0 then
        cleanupDesync()
    end
end

local function applyDesyncStomp()
    if not AutoStompConfig.Enabled or not selectedTarget or not checkKOState(selectedTarget) then
        if autoStompState.activeState then cleanupDesync() end
        return
    end

    local ragdollPart = selectedTarget.Character:FindFirstChild("UpperTorso") or selectedTarget.Character:FindFirstChild("HumanoidRootPart")
    if not ragdollPart then
        if autoStompState.activeState then cleanupDesync() end
        return
    end

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        if autoStompState.activeState then cleanupDesync() end
        return
    end

    if not autoStompState.activeState then
        setupDesync()
    end

    local currentTargetPosition = ragdollPart.Position
    local originalCFrame = character.HumanoidRootPart.CFrame
    local newCFrame = CFrame.new(currentTargetPosition + Vector3.new(0, AutoStompConfig.YOffset, 0))
    
    -- Обновляем позицию визуализатора
    if autoStompState.visualizer then
        autoStompState.visualizer.Position = currentTargetPosition + Vector3.new(0, AutoStompConfig.YOffset, 0)
    end
    
    -- Обновляем привязку текста к цели, если часть тела изменилась
    if autoStompState.stompingText then
        local targetPart = selectedTarget.Character:FindFirstChild("UpperTorso") or 
                          selectedTarget.Character:FindFirstChild("Torso") or 
                          selectedTarget.Character:FindFirstChild("HumanoidRootPart")
        if targetPart then
            autoStompState.stompingText.Adornee = targetPart
            
            -- Если текст не в CoreGui, перемещаем его туда для видимости через стены
            if autoStompState.stompingText.Parent ~= game.CoreGui then
                autoStompState.stompingText.Parent = game.CoreGui
            end
            
            -- Эффект мигания для текста каждые 0.5 секунд
            local currentTime = tick()
            if (currentTime - autoStompState.lastTextBlink) > AutoStompConfig.Text.BlinkSpeed then
                autoStompState.lastTextBlink = currentTime
                
                local textLabel = autoStompState.stompingText:FindFirstChildOfClass("TextLabel")
                if textLabel then
                    -- Меняем между настраиваемыми цветами
                    if textLabel.TextColor3 == AutoStompConfig.Text.PrimaryColor then
                        textLabel.TextColor3 = AutoStompConfig.Text.SecondaryColor
                        textLabel.TextSize = 35 -- Увеличиваем размер
                    else
                        textLabel.TextColor3 = AutoStompConfig.Text.PrimaryColor
                        textLabel.TextSize = 30 -- Уменьшаем размер
                    end
                end
            end
        end
    end

    autoStompState.followPart.CFrame = originalCFrame + Vector3.new(0, 1.5, 0)
    Camera.CameraSubject = autoStompState.followPart

    character.HumanoidRootPart.CFrame = newCFrame
    RunService.RenderStepped:Wait()
    character.HumanoidRootPart.CFrame = originalCFrame

    if autoStompState.lastStompTime and (tick() - autoStompState.lastStompTime) >= AutoStompConfig.StompInterval and autoStompState.stompCounter > 0 then
        performStomp()
    end
end

-- Initialize entity states
local function initEntityStates()
	-- Initialize players
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			entityStates[player] = { isTarget = false }
		end
	end
	Players.PlayerAdded:Connect(function(player)
		if player ~= LocalPlayer then
			entityStates[player] = { isTarget = false }
		end
	end)
	Players.PlayerRemoving:Connect(function(player)
		if entityStates[player] and entityStates[player].isTarget and SilentAimConfig.Checks.TargetDeath then
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
		entityStates[player] = nil
	end)

	-- Initialize bots
	for _, bot in ipairs(BotsFolder:GetChildren()) do
		if bot:IsA("Model") and bot:FindFirstChild("HumanoidRootPart") then
			entityStates[bot] = { isTarget = false }
		end
	end
	BotsFolder.ChildAdded:Connect(function(bot)
		if bot:IsA("Model") and bot:FindFirstChild("HumanoidRootPart") then
			entityStates[bot] = { isTarget = false }
		end
	end)
	BotsFolder.ChildRemoved:Connect(function(bot)
		if entityStates[bot] and entityStates[bot].isTarget and SilentAimConfig.Checks.TargetDeath then
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
		entityStates[bot] = nil
	end)
end

-- Check if entity (player or bot) is alive
local function isEntityAlive(entity)
	local character = entity:IsA("Player") and entity.Character or entity
	return character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0
end

-- Wall check to ensure no obstructions
local function wallCheck(entity)
	if not SilentAimConfig.Checks.WallCheck then
		return true
	end
	local character = entity:IsA("Player") and entity.Character or entity
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return false
	end
	local targetPosition = character.HumanoidRootPart.Position
	local cameraPosition = Camera.CFrame.Position
	local direction = (targetPosition - cameraPosition).Unit
	local distance = (targetPosition - cameraPosition).Magnitude
	local ray = Ray.new(cameraPosition, direction * distance)
	local hitPart, hitPosition = Workspace:FindPartOnRayWithIgnoreList(ray, { LocalPlayer.Character, character })
	return hitPart == nil or (hitPosition - cameraPosition).Magnitude >= distance
end

-- Get closest part to cursor from multiple parts
local function getClosestPart(entity)
	local character = entity:IsA("Player") and entity.Character or entity
	if not character then
		return nil
	end
	if not SilentAimConfig.MultipleParts.Enabled then
		return character:FindFirstChild(SilentAimConfig.AimPart)
	end
	local shortestDistance = Inf
	local closestPart = nil
	local mousePosition = UserInputService:GetMouseLocation()
	
	for _, partName in ipairs(SilentAimConfig.MultipleParts.Parts) do
		local part = character:FindFirstChild(partName)
		if part and part:IsA("BasePart") then
			local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
			if onScreen then
				local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
				if distance < shortestDistance then
					closestPart = part
					shortestDistance = distance
				end
			end
		end
	end
	return closestPart or character:FindFirstChild(SilentAimConfig.AimPart)
end

-- Get closest entity (player or bot) to cursor
local function getClosestEntityToCursor()
	local shortestDistance = Inf
	local closestEntity = nil
	local mousePosition = UserInputService:GetMouseLocation()
	
	-- Check players
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character and isEntityAlive(player) and wallCheck(player) then
			-- Add KO and Grabbed checks
			if (SilentAimConfig.Checks.KOCheck or SilentAimConfig.Checks.GrabbedCheck) and player:IsA("Player") then
				local bodyEffects = player.Character:FindFirstChild("BodyEffects")
				if bodyEffects then
					-- Skip knocked out targets if KO check is enabled
					if SilentAimConfig.Checks.KOCheck and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value then
						continue
					end
					
					-- Skip grabbed targets if Grabbed check is enabled
					if SilentAimConfig.Checks.GrabbedCheck and player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
						continue
					end
				end
			end
	
			local part = player.Character:FindFirstChild(SilentAimConfig.AimPart)
			if part then
				local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
					if distance < shortestDistance then
						closestEntity = player
						shortestDistance = distance
					end
				end
			end
		end
	end

	-- Check bots
	for _, bot in ipairs(BotsFolder:GetChildren()) do
		if bot:IsA("Model") and isEntityAlive(bot) and wallCheck(bot) then
			local part = bot:FindFirstChild(SilentAimConfig.AimPart)
			if part then
				local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
					if distance < shortestDistance then
						closestEntity = bot
						shortestDistance = distance
					end
				end
			end
		end
	end
	
	return closestEntity
end

-- Velmodded Resolver
local function velmoddedResolver(targetEntity)
	local character = targetEntity:IsA("Player") and targetEntity.Character or targetEntity
	if not character or not character:FindFirstChild(SilentAimConfig.AimPart) then
		return nil
	end
	
	local aimPart = character[SilentAimConfig.AimPart]
	local currentTime = tick()
	local deltaTime = currentTime - velmoddedState.last_refresh
	
	if deltaTime > SilentAimConfig.Prediction.Velmodded.ResolverRefresh / 1000 then
		if not velmoddedState.last_position then
			velmoddedState.last_position = aimPart.Position
		else
			velmoddedState.target_velocity = (aimPart.Position - velmoddedState.last_position) / deltaTime
			velmoddedState.last_position = aimPart.Position
		end
		velmoddedState.last_refresh = currentTime
	end
	
	return aimPart.Position + (velmoddedState.target_velocity * SilentAimConfig.Prediction.Velmodded.PredictionFactor)
end

-- Predict target position
local function getPredictedPosition(targetEntity)
	local character = targetEntity:IsA("Player") and targetEntity.Character or targetEntity
	if not character or not character:FindFirstChild(SilentAimConfig.AimPart) then
		return nil
	end
	
	local aimPartPos = character[SilentAimConfig.AimPart].Position
	
	if not SilentAimConfig.Prediction.Enabled then
		return aimPartPos
	end
	
	if SilentAimConfig.Prediction.Type == "Velmodded" then
		velmoddedState.target = targetEntity
		return velmoddedResolver(targetEntity)
	end
	
	if not lastPosition or not lastUpdateTime then
		lastPosition = aimPartPos
		lastUpdateTime = tick()
		predictedPosition = aimPartPos
		return predictedPosition
	end
	
	local currentTime = tick()
	local deltaTime = currentTime - lastUpdateTime
	local predictionType = SilentAimConfig.Prediction.Type
	
	if predictionType == "Vel" then
		local velocity = character[SilentAimConfig.AimPart].Velocity
		predictedPosition = aimPartPos + Vector3.new(
			velocity.X * SilentAimConfig.Prediction.PredictionXZ,
			velocity.Y * SilentAimConfig.Prediction.PredictionY,
			velocity.Z * SilentAimConfig.Prediction.PredictionXZ
		)
	elseif predictionType == "MoveDir" then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		predictedPosition = aimPartPos + (humanoid and humanoid.MoveDirection * (SilentAimConfig.Prediction.PredictionXZ * 10) or Vector3.zero)
	elseif predictionType == "CFrame" then
		if (aimPartPos - lastPosition).Magnitude < 0.001 then
			predictedPosition = aimPartPos
		else
			local distance = (aimPartPos - lastPosition).Magnitude
			local predictedDistance = (distance / deltaTime) * (0.1 * (SilentAimConfig.Prediction.PredictionXZ * 10))
			predictedPosition = aimPartPos + (aimPartPos - lastPosition).Unit * predictedDistance
			local yChange = (aimPartPos.Y - lastPosition.Y) / deltaTime * (0.1 * SilentAimConfig.Prediction.PredictionY)
			predictedPosition = predictedPosition + Vector3.new(0, yChange, 0)
		end
	end
	
	lastUpdateTime = currentTime
	lastPosition = aimPartPos
	return predictedPosition
end

-- Aiming logic with metatable hook
local function setupAimbot()
	local mt = getrawmetatable(game)
	local oldIndex = mt.__index
	setreadonly(mt, false)
	
	mt.__index = function(self, key)
		if not checkcaller() and self == LocalPlayer:GetMouse() and SilentAimConfig.Enabled and (key == "Hit" or key == "Target") then
			if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
				local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
				if character and isEntityAlive(selectedTarget) then
					if SilentAimConfig.Checks.TargetDeath and character:FindFirstChild("Humanoid").Health <= 0 then
						entityStates[selectedTarget].isTarget = false
						selectedTarget = nil
						velmoddedState.target = nil
						velmoddedState.last_position = nil
						velmoddedState.target_velocity = Vector3.zero
						return oldIndex(self, key)
					end
					
					local targetPart = getClosestPart(selectedTarget)
					if targetPart then
						local finalPosition = SilentAimConfig.Prediction.Enabled and getPredictedPosition(selectedTarget) or targetPart.Position
						if finalPosition then
							local humanoid = character:FindFirstChildOfClass("Humanoid")
							if humanoid then
								if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
									finalPosition = finalPosition + Vector3.new(0, SilentAimConfig.Offsets.Jump, 0)
								elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
									finalPosition = finalPosition + Vector3.new(0, SilentAimConfig.Offsets.Fall, 0)
								end
							end
							return key == "Hit" and CFrame.new(finalPosition) or targetPart
						end
					end
				end
			end
		end
		return oldIndex(self, key)
	end
	
	setreadonly(mt, true)
end

-- Функция для получения имени цели
local function getTargetName(entity)
    if entity:IsA("Player") then
        return entity.Name
    elseif entity:IsA("Model") then
        return entity.Name
    end
    return "Target"
end

-- Handle keybind for target selection
local function setupKeybind()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		local keyCode = SilentAimConfig.Keybind
		if typeof(keyCode) == "string" then
			keyCode = Enum.KeyCode[keyCode]
		end
		
		if input.KeyCode == keyCode then
			if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
				-- Deselect current target
				entityStates[selectedTarget].isTarget = false
				local targetName = getTargetName(selectedTarget)
				selectedTarget = nil
				velmoddedState.target = nil
				velmoddedState.last_position = nil
				velmoddedState.target_velocity = Vector3.zero
				
				Library:Notify("Aimbot unlocked", 1.5)
			else
				-- Select new target
				local closestEntity = getClosestEntityToCursor()
				if closestEntity then
					selectedTarget = closestEntity
					entityStates[selectedTarget].isTarget = true
					local targetName = getTargetName(selectedTarget)
					
					if SilentAimConfig.Prediction.Type == "Velmodded" then
						velmoddedState.target = selectedTarget
					end
					
					Library:Notify("Aimbot locked to " .. targetName, 1.5)
				else
					Library:Notify("No target found", 1.5)
				end
			end
		end
	end)
end

-- Fix tools on character spawn/respawn
local function fixTool(character)
	if character then
		for _, tool in ipairs(character:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent = LocalPlayer:FindFirstChildOfClass("Backpack")
				break
			end
		end
	end
end

-- Handle character spawn/respawn
local function setupCharacterHandling()
	fixTool(LocalPlayer.Character)
	LocalPlayer.CharacterAdded:Connect(function(character)
		fixTool(character)
		if selectedTarget and SilentAimConfig.Checks.ResetTargetOnLocalDeath then
			entityStates[selectedTarget].isTarget = false
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
	end)
end

-- BulletTP functions
local BulletTP = {
    Connection = nil,
    LastTool = nil,
    ToolConnections = {}
}

-- Функция для расчета смещения Grip
local function calculateGripOffset(origin, target)
    local actualOrigin = origin * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
    return actualOrigin:ToObjectSpace(target):inverse()
end

-- Функция телепортации пули
local function teleportBullet(tool)
    if not SilentAimConfig.BulletTP.Enabled or not tool or not LocalPlayer.Character then 
        return 
    end
    
    -- Используем только цель аимбота
    if not selectedTarget or not entityStates[selectedTarget] or not entityStates[selectedTarget].isTarget then
        -- Если цель не выбрана, ничего не делаем
        return
    end
    
    local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
    if not character then return end
    
    -- Используем тот же AimPart, что и в аимботе
    local targetPart = character:FindFirstChild(SilentAimConfig.AimPart)
    if not targetPart then return end
    
    -- Получаем позицию с учетом предсказания из аимбота
    local targetPosition
    if SilentAimConfig.Prediction.Enabled then
        targetPosition = getPredictedPosition(selectedTarget)
    else
        targetPosition = targetPart.Position
    end
    
    if not targetPosition then return end
    
    -- Добавляем смещения для прыжка/падения
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Jump, 0)
        elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Fall, 0)
        end
    end
    
    local targetCFrame = CFrame.new(targetPosition)
    
    -- Меняем Grip оружия для телепортации пули
    local originPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("RightHand")
    if originPart then
        local originalGrip = tool.Grip
        
        tool.Parent = LocalPlayer.Backpack
        tool.Grip = calculateGripOffset(originPart.CFrame, targetCFrame)
        tool.Parent = LocalPlayer.Character
        RunService.RenderStepped:Wait()
        tool.Parent = LocalPlayer.Backpack
        tool.Grip = originalGrip
        tool.Parent = LocalPlayer.Character
    end
end

-- Настройка BulletTP через переопределение метатаблицы
local function setupBulletTPMetatable()
    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)
    
    -- Переопределяем метатаблицу для перехвата Mouse.Hit/Mouse.Target
    mt.__index = newcclosure(function(self, key)
        -- Проверяем оригинальное поведение аимбота
        local result = oldIndex(self, key)
        
        -- Добавляем логику BulletTP
        if not checkcaller() and self == LocalPlayer:GetMouse() and SilentAimConfig.BulletTP.Enabled and (key == "Hit" or key == "Target") then
            if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
                local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
                if character then
                    local targetPart = character:FindFirstChild(SilentAimConfig.AimPart)
                    if targetPart then
                        -- Получаем позицию с учетом предсказания
                        local targetPosition
                        if SilentAimConfig.Prediction.Enabled then
                            targetPosition = getPredictedPosition(selectedTarget)
                        else
                            targetPosition = targetPart.Position
                        end
                        
                        if targetPosition then
                            -- Добавляем смещения для прыжка/падения
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            if humanoid then
                                if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                    targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Jump, 0)
                                elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                    targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Fall, 0)
                                end
                            end
                            
                            if key == "Hit" then
                                return CFrame.new(targetPosition)
                            elseif key == "Target" then
                                return targetPart
                            end
                        end
                    end
                end
            end
        end
        
        return result
    end)
    
    setreadonly(mt, true)
end

-- Обработка инструментов для BulletTP
local function handleTool(tool)
    if not tool:IsA("Tool") then return end
    
    -- Отключаем все существующие соединения с Grip
    for _, conn in pairs(getconnections(tool:GetPropertyChangedSignal("Grip"))) do
        conn:Disable()
    end
    
    -- Отключаем старые соединения для этого инструмента
    if BulletTP.ToolConnections[tool] then
        BulletTP.ToolConnections[tool]:Disconnect()
        BulletTP.ToolConnections[tool] = nil
    end
    
    -- Создаем новое соединение на активацию (выстрел)
    BulletTP.ToolConnections[tool] = tool.Activated:Connect(function()
        if SilentAimConfig.BulletTP.Enabled then
            teleportBullet(tool)
        end
    end)
end

-- Настройка BulletTP для персонажа
local function setupBulletTPCharacter(character)
    if not character then return end
    
    -- Обрабатываем текущие инструменты
    for _, child in pairs(character:GetChildren()) do
        if child:IsA("Tool") then
            handleTool(child)
        end
    end
    
    -- Подключаемся к добавлению новых инструментов
    local connection = character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            handleTool(child)
        end
    end)
    
    -- Сохраняем соединение для последующей очистки
    if BulletTP.Connection then
        BulletTP.Connection:Disconnect()
    end
    BulletTP.Connection = connection
    
    -- Подключаемся к удалению инструментов
    character.ChildRemoved:Connect(function(child)
        if child:IsA("Tool") and BulletTP.ToolConnections[child] then
            BulletTP.ToolConnections[child]:Disconnect()
            BulletTP.ToolConnections[child] = nil
        end
    end)
end

-- Инициализация BulletTP
local function setupBulletTP()
    -- Настраиваем метатаблицу
    setupBulletTPMetatable()
    
    -- Настраиваем обработку для текущего персонажа
    if LocalPlayer.Character then
        setupBulletTPCharacter(LocalPlayer.Character)
    end
    
    -- Подключаемся к появлению нового персонажа
    LocalPlayer.CharacterAdded:Connect(function(character)
        setupBulletTPCharacter(character)
    end)
    
    -- Очищаем соединения при удалении персонажа
    LocalPlayer.CharacterRemoving:Connect(function()
        if BulletTP.Connection then
            BulletTP.Connection:Disconnect()
            BulletTP.Connection = nil
        end
        
        for tool, conn in pairs(BulletTP.ToolConnections) do
            conn:Disconnect()
            BulletTP.ToolConnections[tool] = nil
        end
    end)
end

-- Initialize aimbot
initEntityStates()
setupAimbot()
setupKeybind()
setupCharacterHandling()
setupBulletTP() -- Инициализируем BulletTP мониторинг

-- Connect AutoStomp function to RunService
local autoStompConnection = RunService.Heartbeat:Connect(applyDesyncStomp)

-- Clean up when script is stopped
game:BindToClose(function()
    if autoStompConnection then
        autoStompConnection:Disconnect()
    end
    
    if BulletTP.Connection then
        BulletTP.Connection:Disconnect()
    end
    
    for tool, conn in pairs(BulletTP.ToolConnections) do
        conn:Disconnect()
    end
    
    cleanupDesync()
end)

-- Show the UI
Library:Toggle(true)

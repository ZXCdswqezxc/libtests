local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Create the main window
local Window = Library:CreateWindow({
    Title = "TitanCX",
    Footer = "Cursed by 32vision",
    ShowCustomCursor = false,
})

-- Create tabs
local Tabs = {
    Combat = Window:AddTab("Combat", "sword"),
    Movement = Window:AddTab("Movement", "move"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Misc = Window:AddTab("Misc", "box"),
    Other = Window:AddTab("Other", "list"),
    HUD = Window:AddTab("HUD", "monitor"),
}

-- Setup ThemeManager and SaveManager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("ClickGUI")
SaveManager:SetFolder("ClickGUI/settings")

SaveManager:BuildConfigSection(Tabs["HUD"])
ThemeManager:ApplyToTab(Tabs["HUD"])

-- Silent Aim Configuration
local SilentAimConfig = {
	Enabled = true, -- Master switch (изменено обратно на true)
	Keybind = Enum.KeyCode.Q, -- Key to select or deselect target
	AimPart = "HumanoidRootPart", -- Default aim part
	MultipleParts = {
		Enabled = false,
		Parts = { "Head", "UpperTorso", "HumanoidRootPart", "LowerTorso" }
	},
	Prediction = {
		Enabled = true, -- Изменено обратно на true
		Type = "CFrame", -- Resolver modes: Vel, MoveDir, CFrame, Velmodded
		PredictionXZ = 0.12362, -- Horizontal prediction factor (for non-Velmodded resolvers)
		PredictionY = 0.12362, -- Vertical prediction factor (for non-Velmodded resolvers)
		Velmodded = {
			ResolverRefresh = 2, -- Refresh rate in milliseconds for Velmodded resolver (more frequent updates)
			PredictionFactor = 0.12362 -- Scaling factor for Velmodded predicted velocity
		}
	},
	Offsets = {
		Jump = 0, -- Y offset for jumping targets
		Fall = 0  -- Y offset for falling targets
	},
	Checks = {
		WallCheck = false, -- Check for obstructions
		TargetDeath = false, -- Stop aiming if target dies
		ResetTargetOnLocalDeath = false -- Reset target when local player dies
	}
}

-- Add UI elements for Combat/Aimbot
local AimbotGroup = Tabs.Combat:AddLeftGroupbox("Aimbot")

-- Main toggle
local AimbotToggle = AimbotGroup:AddToggle("AimbotEnabled", {
    Text = "Enable",
    Default = true,
    Tooltip = "Toggle aimbot",
    Callback = function(Value)
        SilentAimConfig.Enabled = Value
    end
})

-- Keybind
local AimbotKey = AimbotToggle:AddKeyPicker("AimbotKey", {
    Default = "Q",
    SyncToggleState = false,
    Mode = "Toggle",
    Text = "Lock Key",
    Callback = function(Value)
        -- Проверяем тип данных для предотвращения ошибки
        if type(Value) == "table" and Value.Name then
            -- Сохраняем значение кнопки как строку для UI и как Enum.KeyCode для обработчика
            local keyCode = Value.Name
            SilentAimConfig.KeybindName = keyCode -- Храним строковое представление
            SilentAimConfig.Keybind = Enum.KeyCode[keyCode] -- Преобразуем в Enum.KeyCode
            
            Library:Notify("Key set to " .. keyCode, 1.5)
        end
    end
})

-- Target part
local TargetPartDropdown = AimbotGroup:AddDropdown("TargetPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = SilentAimConfig.AimPart,
    Text = "Target Part",
    Tooltip = "Body part to aim at",
    Callback = function(Value)
        SilentAimConfig.AimPart = Value
    end
})

-- Prediction settings
local PredictionToggle = AimbotGroup:AddToggle("PredictionEnabled", {
    Text = "Prediction",
    Default = true,
    Tooltip = "Predict movement",
    Callback = function(Value)
        SilentAimConfig.Prediction.Enabled = Value
    end
})

local PredictionTypeDropdown = AimbotGroup:AddDropdown("PredictionType", {
    Values = {"Vel", "MoveDir", "CFrame", "Velmodded"},
    Default = SilentAimConfig.Prediction.Type,
    Text = "Method",
    Tooltip = "Prediction calculation method",
    Callback = function(Value)
        SilentAimConfig.Prediction.Type = Value
    end
})

-- Replace XZPredictionSlider with Input
local XZPredictionInput = AimbotGroup:AddInput("PredictionXZ", {
    Text = "XZ Factor",
    Default = tostring(SilentAimConfig.Prediction.PredictionXZ),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Horizontal prediction",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.PredictionXZ = num
            Library:Notify("XZ set to " .. num, 1.5)
        end
    end
})

-- Replace YPredictionSlider with Input
local YPredictionInput = AimbotGroup:AddInput("PredictionY", {
    Text = "Y Factor",
    Default = tostring(SilentAimConfig.Prediction.PredictionY),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Vertical prediction",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.PredictionY = num
            Library:Notify("Y set to " .. num, 1.5)
        end
    end
})

-- Velmodded settings
local VelmoddedGroup = Tabs.Combat:AddRightGroupbox("Advanced")

local ResolverRefreshSlider = VelmoddedGroup:AddSlider("ResolverRefresh", {
    Text = "Refresh",
    Default = SilentAimConfig.Prediction.Velmodded.ResolverRefresh,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Suffix = "ms",
    Callback = function(Value)
        SilentAimConfig.Prediction.Velmodded.ResolverRefresh = Value
    end
})

-- Replace PredictionFactorSlider with Input
local PredictionFactorInput = VelmoddedGroup:AddInput("PredictionFactor", {
    Text = "Factor",
    Default = tostring(SilentAimConfig.Prediction.Velmodded.PredictionFactor),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Prediction multiplier",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.Velmodded.PredictionFactor = num
            Library:Notify("Factor set to " .. num, 1.5)
        end
    end
})

-- Offset settings
local OffsetGroup = Tabs.Combat:AddRightGroupbox("Offsets")

local JumpOffsetSlider = OffsetGroup:AddSlider("JumpOffset", {
    Text = "Jump",
    Default = SilentAimConfig.Offsets.Jump,
    Min = -5,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        SilentAimConfig.Offsets.Jump = Value
    end
})

local FallOffsetSlider = OffsetGroup:AddSlider("FallOffset", {
    Text = "Fall",
    Default = SilentAimConfig.Offsets.Fall,
    Min = -5,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        SilentAimConfig.Offsets.Fall = Value
    end
})

-- Checks
local ChecksGroup = Tabs.Combat:AddLeftGroupbox("Checks")

local WallCheckToggle = ChecksGroup:AddToggle("WallCheck", {
    Text = "Visibility",
    Default = SilentAimConfig.Checks.WallCheck,
    Tooltip = "Target must be visible",
    Callback = function(Value)
        SilentAimConfig.Checks.WallCheck = Value
    end
})

local TargetDeathToggle = ChecksGroup:AddToggle("TargetDeath", {
    Text = "Target Death",
    Default = SilentAimConfig.Checks.TargetDeath,
    Tooltip = "Reset on target death",
    Callback = function(Value)
        SilentAimConfig.Checks.TargetDeath = Value
    end
})

local ResetOnDeathToggle = ChecksGroup:AddToggle("ResetOnDeath", {
    Text = "Local Death",
    Default = SilentAimConfig.Checks.ResetTargetOnLocalDeath,
    Tooltip = "Reset when you die",
    Callback = function(Value)
        SilentAimConfig.Checks.ResetTargetOnLocalDeath = Value
    end
})

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Optimization Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local BotsFolder = Workspace:FindFirstChild("Bots") or Instance.new("Folder", Workspace)
local Inf = math.huge

-- State Variables
local selectedTarget = nil -- Currently selected target (player or bot)
local lastPosition = nil -- For resolver calculations
local lastUpdateTime = nil -- For resolver timing
local predictedPosition = nil -- Predicted target position
local velmoddedState = { -- Velmodded resolver state
	target = nil,
	last_position = nil,
	last_refresh = tick(),
	target_velocity = Vector3.zero
}

-- Entity state table (players and bots)
local entityStates = {} -- Tracks isTarget for each entity (player or bot)

-- Prevent multiple executions
if getgenv().Loaded then
	return
end
getgenv().Loaded = true

-- Initialize entity states
local function initEntityStates()
	-- Initialize players
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			entityStates[player] = { isTarget = false }
		end
	end
	Players.PlayerAdded:Connect(function(player)
		if player ~= LocalPlayer then
			entityStates[player] = { isTarget = false }
		end
	end)
	Players.PlayerRemoving:Connect(function(player)
		if entityStates[player] and entityStates[player].isTarget and SilentAimConfig.Checks.TargetDeath then
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
		entityStates[player] = nil
	end)

	-- Initialize bots
	for _, bot in ipairs(BotsFolder:GetChildren()) do
		if bot:IsA("Model") and bot:FindFirstChild("HumanoidRootPart") then
			entityStates[bot] = { isTarget = false }
		end
	end
	BotsFolder.ChildAdded:Connect(function(bot)
		if bot:IsA("Model") and bot:FindFirstChild("HumanoidRootPart") then
			entityStates[bot] = { isTarget = false }
		end
	end)
	BotsFolder.ChildRemoved:Connect(function(bot)
		if entityStates[bot] and entityStates[bot].isTarget and SilentAimConfig.Checks.TargetDeath then
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
		entityStates[bot] = nil
	end)
end

-- Check if entity (player or bot) is alive
local function isEntityAlive(entity)
	local character = entity:IsA("Player") and entity.Character or entity
	return character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0
end

-- Wall check to ensure no obstructions
local function wallCheck(entity)
	if not SilentAimConfig.Checks.WallCheck then
		return true
	end
	local character = entity:IsA("Player") and entity.Character or entity
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return false
	end
	local targetPosition = character.HumanoidRootPart.Position
	local cameraPosition = Camera.CFrame.Position
	local direction = (targetPosition - cameraPosition).Unit
	local distance = (targetPosition - cameraPosition).Magnitude
	local ray = Ray.new(cameraPosition, direction * distance)
	local hitPart, hitPosition = Workspace:FindPartOnRayWithIgnoreList(ray, { LocalPlayer.Character, character })
	return hitPart == nil or (hitPosition - cameraPosition).Magnitude >= distance
end

-- Get closest part to cursor from multiple parts
local function getClosestPart(entity)
	local character = entity:IsA("Player") and entity.Character or entity
	if not character then
		return nil
	end
	if not SilentAimConfig.MultipleParts.Enabled then
		return character:FindFirstChild(SilentAimConfig.AimPart)
	end
	local shortestDistance = Inf
	local closestPart = nil
	local mousePosition = UserInputService:GetMouseLocation()
	
	for _, partName in ipairs(SilentAimConfig.MultipleParts.Parts) do
		local part = character:FindFirstChild(partName)
		if part and part:IsA("BasePart") then
			local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
			if onScreen then
				local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
				if distance < shortestDistance then
					closestPart = part
					shortestDistance = distance
				end
			end
		end
	end
	return closestPart or character:FindFirstChild(SilentAimConfig.AimPart)
end

-- Get closest entity (player or bot) to cursor
local function getClosestEntityToCursor()
	local shortestDistance = Inf
	local closestEntity = nil
	local mousePosition = UserInputService:GetMouseLocation()
	
	-- Check players
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character and isEntityAlive(player) and wallCheck(player) then
			local part = player.Character:FindFirstChild(SilentAimConfig.AimPart)
			if part then
				local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
					if distance < shortestDistance then
						closestEntity = player
						shortestDistance = distance
					end
				end
			end
		end
	end

	-- Check bots
	for _, bot in ipairs(BotsFolder:GetChildren()) do
		if bot:IsA("Model") and isEntityAlive(bot) and wallCheck(bot) then
			local part = bot:FindFirstChild(SilentAimConfig.AimPart)
			if part then
				local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
					if distance < shortestDistance then
						closestEntity = bot
						shortestDistance = distance
					end
				end
			end
		end
	end
	
	return closestEntity
end

-- Velmodded Resolver
local function velmoddedResolver(targetEntity)
	local character = targetEntity:IsA("Player") and targetEntity.Character or targetEntity
	if not character or not character:FindFirstChild(SilentAimConfig.AimPart) then
		return nil
	end
	
	local aimPart = character[SilentAimConfig.AimPart]
	local currentTime = tick()
	local deltaTime = currentTime - velmoddedState.last_refresh
	
	if deltaTime > SilentAimConfig.Prediction.Velmodded.ResolverRefresh / 1000 then
		if not velmoddedState.last_position then
			velmoddedState.last_position = aimPart.Position
		else
			velmoddedState.target_velocity = (aimPart.Position - velmoddedState.last_position) / deltaTime
			velmoddedState.last_position = aimPart.Position
		end
		velmoddedState.last_refresh = currentTime
	end
	
	return aimPart.Position + (velmoddedState.target_velocity * SilentAimConfig.Prediction.Velmodded.PredictionFactor)
end

-- Predict target position
local function getPredictedPosition(targetEntity)
	local character = targetEntity:IsA("Player") and targetEntity.Character or targetEntity
	if not character or not character:FindFirstChild(SilentAimConfig.AimPart) then
		return nil
	end
	
	local aimPartPos = character[SilentAimConfig.AimPart].Position
	
	if not SilentAimConfig.Prediction.Enabled then
		return aimPartPos
	end
	
	if SilentAimConfig.Prediction.Type == "Velmodded" then
		velmoddedState.target = targetEntity
		return velmoddedResolver(targetEntity)
	end
	
	if not lastPosition or not lastUpdateTime then
		lastPosition = aimPartPos
		lastUpdateTime = tick()
		predictedPosition = aimPartPos
		return predictedPosition
	end
	
	local currentTime = tick()
	local deltaTime = currentTime - lastUpdateTime
	local predictionType = SilentAimConfig.Prediction.Type
	
	if predictionType == "Vel" then
		local velocity = character[SilentAimConfig.AimPart].Velocity
		predictedPosition = aimPartPos + Vector3.new(
			velocity.X * SilentAimConfig.Prediction.PredictionXZ,
			velocity.Y * SilentAimConfig.Prediction.PredictionY,
			velocity.Z * SilentAimConfig.Prediction.PredictionXZ
		)
	elseif predictionType == "MoveDir" then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		predictedPosition = aimPartPos + (humanoid and humanoid.MoveDirection * (SilentAimConfig.Prediction.PredictionXZ * 10) or Vector3.zero)
	elseif predictionType == "CFrame" then
		if (aimPartPos - lastPosition).Magnitude < 0.001 then
			predictedPosition = aimPartPos
		else
			local distance = (aimPartPos - lastPosition).Magnitude
			local predictedDistance = (distance / deltaTime) * (0.1 * (SilentAimConfig.Prediction.PredictionXZ * 10))
			predictedPosition = aimPartPos + (aimPartPos - lastPosition).Unit * predictedDistance
			local yChange = (aimPartPos.Y - lastPosition.Y) / deltaTime * (0.1 * SilentAimConfig.Prediction.PredictionY)
			predictedPosition = predictedPosition + Vector3.new(0, yChange, 0)
		end
	end
	
	lastUpdateTime = currentTime
	lastPosition = aimPartPos
	return predictedPosition
end

-- Aiming logic with metatable hook
local function setupAimbot()
	local mt = getrawmetatable(game)
	local oldIndex = mt.__index
	setreadonly(mt, false)
	
	mt.__index = function(self, key)
		if not checkcaller() and self == LocalPlayer:GetMouse() and SilentAimConfig.Enabled and (key == "Hit" or key == "Target") then
			if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
				local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
				if character and isEntityAlive(selectedTarget) then
					if SilentAimConfig.Checks.TargetDeath and character:FindFirstChild("Humanoid").Health <= 0 then
						entityStates[selectedTarget].isTarget = false
						selectedTarget = nil
						velmoddedState.target = nil
						velmoddedState.last_position = nil
						velmoddedState.target_velocity = Vector3.zero
						return oldIndex(self, key)
					end
					
					local targetPart = getClosestPart(selectedTarget)
					if targetPart then
						local finalPosition = SilentAimConfig.Prediction.Enabled and getPredictedPosition(selectedTarget) or targetPart.Position
						if finalPosition then
							local humanoid = character:FindFirstChildOfClass("Humanoid")
							if humanoid then
								if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
									finalPosition = finalPosition + Vector3.new(0, SilentAimConfig.Offsets.Jump, 0)
								elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
									finalPosition = finalPosition + Vector3.new(0, SilentAimConfig.Offsets.Fall, 0)
								end
							end
							return key == "Hit" and CFrame.new(finalPosition) or targetPart
						end
					end
				end
			end
		end
		return oldIndex(self, key)
	end
	
	setreadonly(mt, true)
end

-- Функция для получения имени цели
local function getTargetName(entity)
    if entity:IsA("Player") then
        return entity.Name
    elseif entity:IsA("Model") then
        return entity.Name
    end
    return "Target"
end

-- Handle keybind for target selection
local function setupKeybind()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		local keyCode = SilentAimConfig.Keybind
		if typeof(keyCode) == "string" then
			keyCode = Enum.KeyCode[keyCode]
		end
		
		if input.KeyCode == keyCode then
			if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
				-- Deselect current target
				entityStates[selectedTarget].isTarget = false
				local targetName = getTargetName(selectedTarget)
				selectedTarget = nil
				velmoddedState.target = nil
				velmoddedState.last_position = nil
				velmoddedState.target_velocity = Vector3.zero
				
				Library:Notify("Aimbot unlocked", 1.5)
			else
				-- Select new target
				local closestEntity = getClosestEntityToCursor()
				if closestEntity then
					selectedTarget = closestEntity
					entityStates[selectedTarget].isTarget = true
					local targetName = getTargetName(selectedTarget)
					
					if SilentAimConfig.Prediction.Type == "Velmodded" then
						velmoddedState.target = selectedTarget
					end
					
					Library:Notify("Aimbot locked to " .. targetName, 1.5)
				else
					Library:Notify("No target found", 1.5)
				end
			end
		end
	end)
end

-- Fix tools on character spawn/respawn
local function fixTool(character)
	if character then
		for _, tool in ipairs(character:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent = LocalPlayer:FindFirstChildOfClass("Backpack")
				break
			end
		end
	end
end

-- Handle character spawn/respawn
local function setupCharacterHandling()
	fixTool(LocalPlayer.Character)
	LocalPlayer.CharacterAdded:Connect(function(character)
		fixTool(character)
		if selectedTarget and SilentAimConfig.Checks.ResetTargetOnLocalDeath then
			entityStates[selectedTarget].isTarget = false
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
	end)
end

-- Initialize aimbot
initEntityStates()
setupAimbot()
setupKeybind()
setupCharacterHandling()

-- Show the UI
Library:Toggle(true)

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Optimization Variables
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local BotsFolder = Workspace:FindFirstChild("Bots") or Instance.new("Folder", Workspace)
local Inf = math.huge

-- Create the main window
local Window = Library:CreateWindow({
    Title = "TitanCX",
    Footer = "Cursed by 32vision",
    ShowCustomCursor = false,
})

-- Create tabs
local CombatTab = Window:AddTab("Combat", "sword")
local MovementTab = Window:AddTab("Movement", "move")
local VisualsTab = Window:AddTab("Visuals", "eye")
local MiscTab = Window:AddTab("Misc", "box")
local OtherTab = Window:AddTab("Other", "list")
local HUDTab = Window:AddTab("HUD", "monitor")

-- Setup ThemeManager and SaveManager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("ClickGUI")
SaveManager:SetFolder("ClickGUI/settings")

SaveManager:BuildConfigSection(HUDTab)
ThemeManager:ApplyToTab(HUDTab)

-- Silent Aim Configuration
local SilentAimConfig = {
	Enabled = true, -- Master switch (изменено обратно на true)
	Keybind = Enum.KeyCode.Q, -- Key to select or deselect target
	AimPart = "HumanoidRootPart", -- Default aim part
	MultipleParts = {
		Enabled = false,
		Parts = { "Head", "UpperTorso", "HumanoidRootPart", "LowerTorso" }
	},
	Prediction = {
		Enabled = true, -- Включено предсказание
		Type = "CFrame", -- Resolver modes: Vel, MoveDir, CFrame, Velmodded
		PredictionXZ = 0, -- Horizontal prediction factor (for non-Velmodded resolvers)
		PredictionY = 0, -- Vertical prediction factor (for non-Velmodded resolvers)
		Velmodded = {
			ResolverRefresh = 2, -- Refresh rate in milliseconds for Velmodded resolver (more frequent updates)
			PredictionFactor = 0 -- Scaling factor for Velmodded predicted velocity
		}
	},
	Offsets = {
		Jump = 0, -- Y offset for jumping targets
		Fall = 0  -- Y offset for falling targets
	},
	Checks = {
		WallCheck = false, -- Check for obstructions
		TargetDeath = false, -- Stop aiming if target dies
		ResetTargetOnLocalDeath = false, -- Reset target when local player dies
		KOCheck = false, -- Check if target is knocked out
		GrabbedCheck = false -- Check if target is grabbed
	},
	BulletTP = {
		Enabled = false, -- Simple on/off toggle
	},
	LookAt = {
		Enabled = false -- Поворачивать персонажа в сторону цели
	},
	TargetHighlight = {
		Enabled = false, -- Highlight target through walls
		FillColor = Color3.fromRGB(255, 0, 0), -- Red fill color
		OutlineColor = Color3.fromRGB(255, 255, 0) -- Yellow outline color
	},
    Tracer = {
        Enabled = false, -- Draw line to target
        Color = Color3.fromRGB(255, 0, 0), -- Red tracer line
        Thickness = 2 -- Tracer thickness
    }
}

-- AutoStomp Configuration
local AutoStompConfig = {
	Enabled = false, -- Master switch for AutoStomp
	StompCount = 20, -- Number of stomps to perform
	StompInterval = 0.099, -- Time between stomps in seconds
	YOffset = 2, -- Vertical offset for stomping position
	Visualizer = {
		Enabled = true, -- Enable visual indicator
		Color = Color3.fromRGB(255, 0, 0), -- Red color
		Transparency = 0.3, -- 30% transparency
		Size = Vector3.new(5, 15, 5) -- Size of visualizer (увеличено в 10 раз)
	},
	Text = {
		PrimaryColor = Color3.fromRGB(255, 0, 0), -- Первый цвет (красный)
		SecondaryColor = Color3.fromRGB(255, 255, 0), -- Второй цвет (желтый)
		BlinkSpeed = 0.5 -- Скорость мигания в секундах
	}
}

-- Target Strafe Configuration
local TargetStrafeConfig = {
    Enabled = false,
    Radius = 10,
    Speed = 5,
    YOffset = 0,
    AvoidWalls = true,
    LerpSpeed = 0.1,
    State = {
        Angle = 0,
        OriginalCollision = nil,
        NoClipConnection = nil -- Для сохранения соединения NoClip
    }
}

-- Add UI elements for Combat/Aimbot
local AimbotGroup = CombatTab:AddLeftGroupbox("Aimbot")

-- Main toggle
local AimbotToggle = AimbotGroup:AddToggle("AimbotEnabled", {
    Text = "Enable",
    Default = true,
    Tooltip = "Toggle aimbot",
    Callback = function(Value)
        SilentAimConfig.Enabled = Value
    end
})

-- Keybind
local AimbotKey = AimbotToggle:AddKeyPicker("AimbotKey", {
    Default = "Q",
    SyncToggleState = false,
    Mode = "Toggle",
    Text = "Lock Key",
    Callback = function(Value)
        -- Проверяем тип данных для предотвращения ошибки
        if type(Value) == "table" and Value.Name then
            -- Сохраняем значение кнопки как строку для UI и как Enum.KeyCode для обработчика
            local keyCode = Value.Name
            SilentAimConfig.KeybindName = keyCode -- Храним строковое представление
            SilentAimConfig.Keybind = Enum.KeyCode[keyCode] -- Преобразуем в Enum.KeyCode
            
            Library:Notify("Key set to " .. keyCode, 1.5)
        end
    end
})

-- Target part
local TargetPartDropdown = AimbotGroup:AddDropdown("TargetPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = SilentAimConfig.AimPart,
    Text = "Target Part",
    Tooltip = "Body part to aim at",
    Callback = function(Value)
        SilentAimConfig.AimPart = Value
    end
})

-- Prediction settings
local PredictionToggle = AimbotGroup:AddToggle("PredictionEnabled", {
    Text = "Prediction",
    Default = true,
    Tooltip = "Predict movement",
    Callback = function(Value)
        SilentAimConfig.Prediction.Enabled = Value
    end
})

local PredictionTypeDropdown = AimbotGroup:AddDropdown("PredictionType", {
    Values = {"Vel", "MoveDir", "CFrame", "Velmodded"},
    Default = SilentAimConfig.Prediction.Type,
    Text = "Method",
    Tooltip = "Prediction calculation method",
    Callback = function(Value)
        SilentAimConfig.Prediction.Type = Value
    end
})

-- Replace XZPredictionSlider with Input
local XZPredictionInput = AimbotGroup:AddInput("PredictionXZ", {
    Text = "XZ Factor",
    Default = tostring(SilentAimConfig.Prediction.PredictionXZ),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Horizontal prediction",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.PredictionXZ = num
            Library:Notify("XZ set to " .. num, 1.5)
        end
    end
})

-- Replace YPredictionSlider with Input
local YPredictionInput = AimbotGroup:AddInput("PredictionY", {
    Text = "Y Factor",
    Default = tostring(SilentAimConfig.Prediction.PredictionY),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Vertical prediction",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.PredictionY = num
            Library:Notify("Y set to " .. num, 1.5)
        end
    end
})

-- Velmodded settings
local VelmoddedGroup = CombatTab:AddRightGroupbox("Advanced")

local ResolverRefreshSlider = VelmoddedGroup:AddSlider("ResolverRefresh", {
    Text = "Refresh",
    Default = SilentAimConfig.Prediction.Velmodded.ResolverRefresh,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Suffix = "ms",
    Callback = function(Value)
        SilentAimConfig.Prediction.Velmodded.ResolverRefresh = Value
    end
})

-- Replace PredictionFactorSlider with Input
local PredictionFactorInput = VelmoddedGroup:AddInput("PredictionFactor", {
    Text = "Factor",
    Default = tostring(SilentAimConfig.Prediction.Velmodded.PredictionFactor),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Prediction multiplier",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            SilentAimConfig.Prediction.Velmodded.PredictionFactor = num
            Library:Notify("Factor set to " .. num, 1.5)
        end
    end
})

-- Offset settings
local OffsetGroup = CombatTab:AddRightGroupbox("Offsets")

local JumpOffsetSlider = OffsetGroup:AddSlider("JumpOffset", {
    Text = "Jump",
    Default = SilentAimConfig.Offsets.Jump,
    Min = -5,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        SilentAimConfig.Offsets.Jump = Value
    end
})

local FallOffsetSlider = OffsetGroup:AddSlider("FallOffset", {
    Text = "Fall",
    Default = SilentAimConfig.Offsets.Fall,
    Min = -5,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        SilentAimConfig.Offsets.Fall = Value
    end
})

-- Checks
local ChecksGroup = CombatTab:AddLeftGroupbox("Checks")

local WallCheckToggle = ChecksGroup:AddToggle("WallCheck", {
    Text = "Visibility",
    Default = SilentAimConfig.Checks.WallCheck,
    Tooltip = "Target must be visible",
    Callback = function(Value)
        SilentAimConfig.Checks.WallCheck = Value
    end
})

local TargetDeathToggle = ChecksGroup:AddToggle("TargetDeath", {
    Text = "Target Death",
    Default = SilentAimConfig.Checks.TargetDeath,
    Tooltip = "Reset on target death",
    Callback = function(Value)
        SilentAimConfig.Checks.TargetDeath = Value
    end
})

local ResetOnDeathToggle = ChecksGroup:AddToggle("ResetOnDeath", {
    Text = "Local Death",
    Default = SilentAimConfig.Checks.ResetTargetOnLocalDeath,
    Tooltip = "Reset when you die",
    Callback = function(Value)
        SilentAimConfig.Checks.ResetTargetOnLocalDeath = Value
    end
})

-- Add KO Check and Grabbed Check to Checks group
local KOCheckToggle = ChecksGroup:AddToggle("KOCheck", {
    Text = "K.O. Check",
    Default = SilentAimConfig.Checks.KOCheck,
    Tooltip = "Skip KO'd targets",
    Callback = function(Value)
        SilentAimConfig.Checks.KOCheck = Value
    end
})

local GrabbedCheckToggle = ChecksGroup:AddToggle("GrabbedCheck", {
    Text = "Grabbed Check",
    Default = SilentAimConfig.Checks.GrabbedCheck,
    Tooltip = "Skip grabbed targets",
    Callback = function(Value)
        SilentAimConfig.Checks.GrabbedCheck = Value
    end
})

-- Add Extra group with AutoStomp
local ExtraGroup = CombatTab:AddRightGroupbox("Extra")

-- Add Target Highlight group
local TargetHighlightGroup = CombatTab:AddLeftGroupbox("Target Highlight")

-- Main toggle for Target Highlight
local TargetHighlightToggle = TargetHighlightGroup:AddToggle("TargetHighlightEnabled", {
    Text = "Enable",
    Default = SilentAimConfig.TargetHighlight.Enabled,
    Tooltip = "Highlight target through walls",
    Callback = function(Value)
        SilentAimConfig.TargetHighlight.Enabled = Value
        
        -- Clean up existing highlight if disabled
        if not Value and targetHighlight then
            targetHighlight:Destroy()
            targetHighlight = nil
        elseif Value and selectedTarget then
            -- Create new highlight if enabled and we have a target
            createTargetHighlight()
        end
        
        Library:Notify("Target Highlight " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- Fill color picker
local FillColorPicker = TargetHighlightToggle:AddColorPicker("FillColor", {
    Default = SilentAimConfig.TargetHighlight.FillColor,
    Title = "Fill Color",
    Callback = function(Value)
        SilentAimConfig.TargetHighlight.FillColor = Value
        
        -- Direct update of active highlight
        if targetHighlight then
            targetHighlight.FillColor = Value
        end
    end
})

-- Outline color picker
local OutlineColorPicker = TargetHighlightToggle:AddColorPicker("OutlineColor", {
    Default = SilentAimConfig.TargetHighlight.OutlineColor,
    Title = "Outline Color",
    Callback = function(Value)
        SilentAimConfig.TargetHighlight.OutlineColor = Value
        
        -- Direct update of active highlight
        if targetHighlight then
            targetHighlight.OutlineColor = Value
        end
    end
})

-- Add Tracer group
local TracerGroup = CombatTab:AddLeftGroupbox("Tracer to Target")

-- Main toggle for Tracer
local TracerToggle = TracerGroup:AddToggle("TracerEnabled", {
    Text = "Enable",
    Default = SilentAimConfig.Tracer.Enabled,
    Tooltip = "Draw line from cursor to target",
    Callback = function(Value)
        SilentAimConfig.Tracer.Enabled = Value
        
        -- Clean up existing tracer if disabled
        if not Value then
            cleanupTracer()
        elseif Value and selectedTarget then
            -- Create new tracer if enabled and we have a target
            createTargetTracer()
        end
        
        Library:Notify("Tracer " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- Tracer color picker
local TracerColorPicker = TracerToggle:AddColorPicker("TracerColor", {
    Default = SilentAimConfig.Tracer.Color,
    Title = "Tracer Color",
    Callback = function(Value)
        SilentAimConfig.Tracer.Color = Value
        
        -- Direct update of active tracer
        if tracerLine then
            tracerLine.Color = Value
        end
    end
})

-- Thickness slider
local ThicknessSlider = TracerGroup:AddSlider("TracerThickness", {
    Text = "Thickness",
    Default = SilentAimConfig.Tracer.Thickness,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Callback = function(Value)
        SilentAimConfig.Tracer.Thickness = Value
        
        -- Direct update of active tracer
        if tracerLine then
            tracerLine.Thickness = Value
        end
    end
})

-- Add BulletTP group
local BulletTPGroup = CombatTab:AddLeftGroupbox("Bullet TP")

-- Main toggle
local BulletTPToggle = BulletTPGroup:AddToggle("BulletTPEnabled", {
    Text = "Enable",
    Default = SilentAimConfig.BulletTP.Enabled,
    Tooltip = "Teleport bullets to aimbot target (uses same prediction settings as aimbot)",
    Callback = function(Value)
        SilentAimConfig.BulletTP.Enabled = Value
        Library:Notify("Bullet TP " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- Add Keybind to BulletTP toggle
local BulletTPKey = BulletTPToggle:AddKeyPicker("BulletTPKey", {
    Default = "C",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Toggle Key",
    Callback = function(Value)
        SilentAimConfig.BulletTP.Enabled = Value
        Library:Notify("Bullet TP " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- Add GripPos group
local GripPosGroup = CombatTab:AddRightGroupbox("Grip Position")

-- Grip Position Configuration
local GripPosConfig = {
    Enabled = false,
    Front = 0,
    Side = 0,
    Height = 0,
    Random = {
        Enabled = false,
        Range = 7
    }
}

-- Main toggle for Grip Position
local GripPosToggle = GripPosGroup:AddToggle("GripPosEnabled", {
    Text = "Fixed Position",
    Default = GripPosConfig.Enabled,
    Tooltip = "Изменить позицию грипа оружия",
    Callback = function(Value)
        GripPosConfig.Enabled = Value
        
        -- Логика управления grip position
        if GripPosConfig.Enabled then
            -- Отключаем Random режим если включен
            if GripPosConfig.Random.Enabled then
                GripPosConfig.Random.Enabled = false
                
                -- Отключим RandomGripToggle только если он уже инициализирован
                if RandomGripToggle then 
                    pcall(function() RandomGripToggle:SetValue(false) end)
                end
            end
            
            -- Отключаем старый цикл если был
            if GripPosLoop then
                pcall(function() GripPosLoop:Disconnect() end)
                GripPosLoop = nil
            end
            
            -- Проверяем наличие RunService и Stepped
            if not RunService then
                RunService = game:GetService("RunService")
            end
            
            if not RunService or not RunService.Stepped then
                Library:Notify("RunService не доступен", 1.5)
                return
            end
            
            -- Функция, запускающаяся в цикле при включенном режиме
            GripPosLoop = RunService.Stepped:Connect(function()
                if not GripPosConfig.Enabled then return end
                
                local character = LocalPlayer and LocalPlayer.Character
                if not character then return end
                
                local tool = character:FindFirstChildOfClass("Tool")
                if not tool then return end
                
                tool.GripPos = Vector3.new(-GripPosConfig.Side, -GripPosConfig.Height, GripPosConfig.Front)
            end)
        else
            -- Отключаем цикл если был включен
            if GripPosLoop then
                pcall(function() GripPosLoop:Disconnect() end)
                GripPosLoop = nil
            end
            
            -- Возвращаем grip position в исходное состояние
            local character = LocalPlayer and LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool then
                    tool.GripPos = Vector3.new(0, 0, 0)
                end
            end
        end
    end
})

-- Sliders for Grip Position
local GripFrontSlider = GripPosGroup:AddSlider("GripFront", {
    Text = "Front",
    Default = GripPosConfig.Front,
    Min = -15,
    Max = 15,
    Rounding = 0,
    Suffix = " studs",
    Callback = function(Value)
        GripPosConfig.Front = Value
    end
})

local GripSideSlider = GripPosGroup:AddSlider("GripSide", {
    Text = "Side",
    Default = GripPosConfig.Side,
    Min = -15,
    Max = 15,
    Rounding = 0,
    Suffix = " studs",
    Callback = function(Value)
        GripPosConfig.Side = Value
    end
})

local GripHeightSlider = GripPosGroup:AddSlider("GripHeight", {
    Text = "Height",
    Default = GripPosConfig.Height,
    Min = -15,
    Max = 15,
    Rounding = 0,
    Suffix = " studs",
    Callback = function(Value)
        GripPosConfig.Height = Value
    end
})

-- Random Grip Position
local RandomGripToggle = GripPosGroup:AddToggle("RandomGripEnabled", {
    Text = "Random Position",
    Default = GripPosConfig.Random.Enabled,
    Tooltip = "Случайная позиция грипа оружия",
    Callback = function(Value)
        GripPosConfig.Random.Enabled = Value
        
        -- Сбрасываем состояние обычного режима
        GripPosConfig.Enabled = false
        
        -- Логика управления случайным grip position
        if GripPosConfig.Random.Enabled then
            -- Отключаем старый цикл если был
            if RandomGripLoop then
                pcall(function() RandomGripLoop:Disconnect() end)
                RandomGripLoop = nil
            end
            
            -- Проверяем наличие RunService и Stepped
            if not RunService then
                RunService = game:GetService("RunService")
            end
            
            if not RunService or not RunService.Stepped then
                Library:Notify("RunService не доступен", 1.5)
                return
            end
            
            -- Функция, запускающаяся в цикле при включенном режиме
            RandomGripLoop = RunService.Stepped:Connect(function()
                if not GripPosConfig.Random.Enabled then return end
                
                local character = LocalPlayer and LocalPlayer.Character
                if not character then return end
                
                local tool = character:FindFirstChildOfClass("Tool")
                if not tool then return end
                
                tool.GripPos = Vector3.new(
                    math.random(-GripPosConfig.Random.Range, GripPosConfig.Random.Range),
                    math.random(-GripPosConfig.Random.Range, GripPosConfig.Random.Range),
                    math.random(-GripPosConfig.Random.Range, GripPosConfig.Random.Range)
                )
            end)
        else
            -- Отключаем цикл если был включен
            if RandomGripLoop then
                pcall(function() RandomGripLoop:Disconnect() end)
                RandomGripLoop = nil
            end
            
            -- Возвращаем grip position в исходное состояние
            local character = LocalPlayer and LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool then
                    tool.GripPos = Vector3.new(0, 0, 0)
                end
            end
        end
    end
})

-- Range slider for Random Grip
local RangeSlider = GripPosGroup:AddSlider("RandomRange", {
    Text = "Random Range",
    Default = GripPosConfig.Random.Range,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Suffix = " studs",
    Callback = function(Value)
        GripPosConfig.Random.Range = Value
    end
})

-- Add Stuff group
local StuffGroup = CombatTab:AddLeftGroupbox("Stuff")

-- Target Look toggle
local LookAtToggle = StuffGroup:AddToggle("LookAtEnabled", {
    Text = "Target Look",
    Default = SilentAimConfig.LookAt.Enabled,
    Tooltip = "Turn character towards target",
    Callback = function(Value)
        SilentAimConfig.LookAt.Enabled = Value
        
        -- Управление AutoRotate
        local character = LocalPlayer.Character
        if character and character:FindFirstChildOfClass("Humanoid") then
            character:FindFirstChildOfClass("Humanoid").AutoRotate = not Value
        end
        
        Library:Notify("Target Look " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- AutoStomp UI
local AutoStompToggle = ExtraGroup:AddToggle("AutoStompEnabled", {
    Text = "Auto Stomp",
    Default = AutoStompConfig.Enabled,
    Tooltip = "Automatically stomp KO'd targets",
    Callback = function(Value)
        AutoStompConfig.Enabled = Value
        Library:Notify("Auto Stomp " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

local StompCountSlider = ExtraGroup:AddSlider("StompCount", {
    Text = "Stomp Count",
    Default = AutoStompConfig.StompCount,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Callback = function(Value)
        AutoStompConfig.StompCount = Value
    end
})

local StompIntervalInput = ExtraGroup:AddInput("StompInterval", {
    Text = "Interval",
    Default = tostring(AutoStompConfig.StompInterval),
    Numeric = true,
    Finished = true,
    Placeholder = "Value...",
    Tooltip = "Time between stomps",
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            AutoStompConfig.StompInterval = num
            Library:Notify("Interval set to " .. num, 1.5)
        end
    end
})

local YOffsetSlider = ExtraGroup:AddSlider("YOffset", {
    Text = "Y Offset",
    Default = AutoStompConfig.YOffset,
    Min = 0,
    Max = 5,
    Rounding = 2,
    Suffix = " studs",
    Callback = function(Value)
        AutoStompConfig.YOffset = Value
    end
})

-- Visualizer settings
local VisualizerToggle = ExtraGroup:AddToggle("VisualizerEnabled", {
    Text = "Visualizer",
    Default = AutoStompConfig.Visualizer.Enabled,
    Tooltip = "Show desync position",
    Callback = function(Value)
        AutoStompConfig.Visualizer.Enabled = Value
        
        -- Update active visualizer if desync is currently running
        if autoStompState.activeState then
            if Value and not autoStompState.visualizer then
                autoStompState.visualizer = createVisualizer()
            elseif not Value and autoStompState.visualizer then
                autoStompState.visualizer:Destroy()
                autoStompState.visualizer = nil
            end
        end
    end
})

-- Box color
local BoxColorPicker = VisualizerToggle:AddColorPicker("VisualizerColorR", {
    Default = AutoStompConfig.Visualizer.Color,
    Title = "Box Color",
    Callback = function(Value)
        AutoStompConfig.Visualizer.Color = Value
        
        -- Update active visualizer if it exists
        if autoStompState.visualizer then
            autoStompState.visualizer.Color = Value
        end
    end
})

-- Text primary color
local PrimaryColorPicker = VisualizerToggle:AddColorPicker("PrimaryColorPicker", {
    Default = AutoStompConfig.Text.PrimaryColor,
    Title = "Text Color 1",
    Callback = function(Value)
        AutoStompConfig.Text.PrimaryColor = Value
    end
})

-- Text secondary color
local SecondaryColorPicker = VisualizerToggle:AddColorPicker("SecondaryColorPicker", {
    Default = AutoStompConfig.Text.SecondaryColor, 
    Title = "Text Color 2",
    Callback = function(Value)
        AutoStompConfig.Text.SecondaryColor = Value
    end
})

-- State Variables
local selectedTarget = nil -- Currently selected target (player or bot)
local lastPosition = nil -- For resolver calculations
local lastUpdateTime = nil -- For resolver timing
local predictedPosition = nil -- Predicted target position
local velmoddedState = { -- Velmodded resolver state
	target = nil,
	last_position = nil,
	last_refresh = tick(),
	target_velocity = Vector3.zero
}

-- AutoStomp state variables
local autoStompState = {
    activeState = false, -- Active state (is desync and stomp being performed)
    followPart = nil, -- Part for camera to follow during desync
    stompCounter = 0, -- Current stomp count
    lastStompTime = nil, -- Last time a stomp was performed
    visualizer = nil, -- Visual indicator for desync position
    stompingText = nil, -- Text label to show "STOMPING"
    lastTextBlink = 0 -- Timer for text blinking effect
}

-- Entity state table (players and bots)
local entityStates = {} -- Tracks isTarget for each entity (player or bot)

-- Storage for highlight and tracer objects
local targetHighlight = nil
local tracerLine = nil

-- Prevent multiple executions
if getgenv().Loaded then
	return
end
getgenv().Loaded = true

-- Check if target is knocked out and not grabbed
local function checkKOState(entity)
    if not entity or not entity:IsA("Player") or not entity.Character then
        return false
    end
    
    local bodyEffects = entity.Character:FindFirstChild("BodyEffects")
    if not bodyEffects then
        return false
    end
    
    local ko = bodyEffects:FindFirstChild("K.O")
    local isGrabbed = entity.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    
    return ko and ko.Value and not isGrabbed
end

-- AutoStomp functions
local function createFollowPart()
    local part = Instance.new("Part")
    part.Name = "FollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Parent = Workspace
    return part
end

local function createVisualizer()
    if not AutoStompConfig.Visualizer.Enabled then
        return nil
    end
    
    local visualizer = Instance.new("Part")
    visualizer.Name = "DesyncVisualizer"
    visualizer.Anchored = true
    visualizer.CanCollide = false
    visualizer.Material = Enum.Material.ForceField
    visualizer.Size = AutoStompConfig.Visualizer.Size
    visualizer.Color = AutoStompConfig.Visualizer.Color
    visualizer.Transparency = AutoStompConfig.Visualizer.Transparency
    visualizer.Parent = Workspace
    return visualizer
end

-- Функция для создания текста "STOMPING"
local function createStompingText()
    -- Создаем BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "StompingLabel"
    billboardGui.Size = UDim2.new(0, 200, 0, 50)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Размещаем над целью
    billboardGui.AlwaysOnTop = true
    billboardGui.LightInfluence = 0
    billboardGui.MaxDistance = 100
    billboardGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Для видимости через стены
    
    -- Устанавливаем пометку "AlwaysOnTop" для видимости через стены
    local humanoidRootPart = Workspace.CurrentCamera
    if humanoidRootPart then
        billboardGui.Adornee = humanoidRootPart
    end
    
    -- Создаем текстовую метку
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = AutoStompConfig.Text.PrimaryColor
    textLabel.TextStrokeTransparency = 0 -- Черная обводка
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    textLabel.TextSize = 30
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Text = "STOMPING"
    textLabel.TextScaled = true
    textLabel.ZIndex = 10 -- Высокий Z-Index для отображения поверх других объектов
    textLabel.Parent = billboardGui
    
    return billboardGui
end

local function setupDesync()
    if autoStompState.activeState then return end
    autoStompState.activeState = true
    autoStompState.followPart = createFollowPart()
    autoStompState.visualizer = createVisualizer()
    autoStompState.stompCounter = AutoStompConfig.StompCount
    autoStompState.lastStompTime = tick()
    
    -- Создаем текстовую метку и прикрепляем к цели
    if selectedTarget and selectedTarget:IsA("Player") and selectedTarget.Character then
        autoStompState.stompingText = createStompingText()
        
        -- Размещаем метку в пространстве
        autoStompState.stompingText.Parent = game.CoreGui -- Для видимости через стены
        
        -- Точка привязки для позиционирования
        local targetPart = selectedTarget.Character:FindFirstChild("UpperTorso") or 
                          selectedTarget.Character:FindFirstChild("Torso") or 
                          selectedTarget.Character:FindFirstChild("HumanoidRootPart")
        
        if targetPart then
            autoStompState.stompingText.Adornee = targetPart
        else
            autoStompState.stompingText.Adornee = Workspace.CurrentCamera
        end
    end
    
    Library:Notify("Desync activated", 1)
end

local function cleanupDesync()
    if not autoStompState.activeState then return end
    autoStompState.activeState = false
    
    if autoStompState.followPart then
        autoStompState.followPart:Destroy()
        autoStompState.followPart = nil
    end
    
    if autoStompState.visualizer then
        autoStompState.visualizer:Destroy()
        autoStompState.visualizer = nil
    end
    
    if autoStompState.stompingText then
        autoStompState.stompingText:Destroy()
        autoStompState.stompingText = nil
    end
    
    autoStompState.stompCounter = 0
    autoStompState.lastStompTime = nil
    Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    
    Library:Notify("Desync deactivated", 1)
end

local function performStomp()
    ReplicatedStorage.MainEvent:FireServer("Stomp")
    if ReplicatedStorage:FindFirstChild("assets") and ReplicatedStorage.assets:FindFirstChild("dh") then
        ReplicatedStorage.assets.dh.MainEvent:FireServer("Stomp")
    end
    autoStompState.stompCounter = autoStompState.stompCounter - 1
    autoStompState.lastStompTime = tick()
    if autoStompState.stompCounter <= 0 then
        cleanupDesync()
    end
end

local function applyDesyncStomp()
    if not AutoStompConfig.Enabled or not selectedTarget or not checkKOState(selectedTarget) then
        if autoStompState.activeState then cleanupDesync() end
        return
    end

    local ragdollPart = selectedTarget.Character:FindFirstChild("UpperTorso") or selectedTarget.Character:FindFirstChild("HumanoidRootPart")
    if not ragdollPart then
        if autoStompState.activeState then cleanupDesync() end
        return
    end

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        if autoStompState.activeState then cleanupDesync() end
        return
    end

    if not autoStompState.activeState then
        setupDesync()
    end

    local currentTargetPosition = ragdollPart.Position
    local originalCFrame = character.HumanoidRootPart.CFrame
    local newCFrame = CFrame.new(currentTargetPosition + Vector3.new(0, AutoStompConfig.YOffset, 0))
    
    -- Обновляем позицию визуализатора
    if autoStompState.visualizer then
        autoStompState.visualizer.Position = currentTargetPosition + Vector3.new(0, AutoStompConfig.YOffset, 0)
    end
    
    -- Обновляем привязку текста к цели, если часть тела изменилась
    if autoStompState.stompingText then
        local targetPart = selectedTarget.Character:FindFirstChild("UpperTorso") or 
                          selectedTarget.Character:FindFirstChild("Torso") or 
                          selectedTarget.Character:FindFirstChild("HumanoidRootPart")
        if targetPart then
            autoStompState.stompingText.Adornee = targetPart
            
            -- Если текст не в CoreGui, перемещаем его туда для видимости через стены
            if autoStompState.stompingText.Parent ~= game.CoreGui then
                autoStompState.stompingText.Parent = game.CoreGui
            end
            
            -- Эффект мигания для текста каждые 0.5 секунд
            local currentTime = tick()
            if (currentTime - autoStompState.lastTextBlink) > AutoStompConfig.Text.BlinkSpeed then
                autoStompState.lastTextBlink = currentTime
                
                local textLabel = autoStompState.stompingText:FindFirstChildOfClass("TextLabel")
                if textLabel then
                    -- Меняем между настраиваемыми цветами
                    if textLabel.TextColor3 == AutoStompConfig.Text.PrimaryColor then
                        textLabel.TextColor3 = AutoStompConfig.Text.SecondaryColor
                        textLabel.TextSize = 35 -- Увеличиваем размер
                    else
                        textLabel.TextColor3 = AutoStompConfig.Text.PrimaryColor
                        textLabel.TextSize = 30 -- Уменьшаем размер
                    end
                end
            end
        end
    end

    autoStompState.followPart.CFrame = originalCFrame + Vector3.new(0, 1.5, 0)
    Camera.CameraSubject = autoStompState.followPart

    character.HumanoidRootPart.CFrame = newCFrame
    RunService.RenderStepped:Wait()
    character.HumanoidRootPart.CFrame = originalCFrame

    if autoStompState.lastStompTime and (tick() - autoStompState.lastStompTime) >= AutoStompConfig.StompInterval and autoStompState.stompCounter > 0 then
        performStomp()
    end
end

-- Function to make character look at target
local function lookAtTarget()
    if not SilentAimConfig.LookAt.Enabled or not selectedTarget or not entityStates[selectedTarget] or not entityStates[selectedTarget].isTarget then
        -- Если функция отключена, но AutoRotate всё ещё false, включаем его обратно
        local character = LocalPlayer.Character
        if character and character:FindFirstChildOfClass("Humanoid") and character:FindFirstChildOfClass("Humanoid").AutoRotate == false then
            character:FindFirstChildOfClass("Humanoid").AutoRotate = true
        end
        return
    end
    
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.AutoRotate then
        humanoid.AutoRotate = false
    end
    
    local targetCharacter = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
    if not targetCharacter or not targetCharacter:FindFirstChild(SilentAimConfig.AimPart) then
        return
    end
    
    local targetPos = targetCharacter[SilentAimConfig.AimPart].Position
    local localPos = character.HumanoidRootPart.Position
    
    -- Только поворот в горизонтальной плоскости (меняем только YAW)
    local direction = (targetPos - localPos).Unit
    direction = Vector3.new(direction.X, 0, direction.Z).Unit
    character.HumanoidRootPart.CFrame = CFrame.new(localPos, localPos + direction)
end

-- Initialize entity states
local function initEntityStates()
	-- Initialize players
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			entityStates[player] = { isTarget = false }
		end
	end
	Players.PlayerAdded:Connect(function(player)
		if player ~= LocalPlayer then
			entityStates[player] = { isTarget = false }
		end
	end)
	Players.PlayerRemoving:Connect(function(player)
		if entityStates[player] and entityStates[player].isTarget and SilentAimConfig.Checks.TargetDeath then
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
		entityStates[player] = nil
	end)

	-- Initialize bots
	for _, bot in ipairs(BotsFolder:GetChildren()) do
		if bot:IsA("Model") and bot:FindFirstChild("HumanoidRootPart") then
			entityStates[bot] = { isTarget = false }
		end
	end
	BotsFolder.ChildAdded:Connect(function(bot)
		if bot:IsA("Model") and bot:FindFirstChild("HumanoidRootPart") then
			entityStates[bot] = { isTarget = false }
		end
	end)
	BotsFolder.ChildRemoved:Connect(function(bot)
		if entityStates[bot] and entityStates[bot].isTarget and SilentAimConfig.Checks.TargetDeath then
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
		entityStates[bot] = nil
	end)
end

-- Check if entity (player or bot) is alive
local function isEntityAlive(entity)
	local character = entity:IsA("Player") and entity.Character or entity
	return character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0
end

-- Wall check to ensure no obstructions
local function wallCheck(entity)
	if not SilentAimConfig.Checks.WallCheck then
		return true
	end
	local character = entity:IsA("Player") and entity.Character or entity
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return false
	end
	local targetPosition = character.HumanoidRootPart.Position
	local cameraPosition = Camera.CFrame.Position
	local direction = (targetPosition - cameraPosition).Unit
	local distance = (targetPosition - cameraPosition).Magnitude
	local ray = Ray.new(cameraPosition, direction * distance)
	local hitPart, hitPosition = Workspace:FindPartOnRayWithIgnoreList(ray, { LocalPlayer.Character, character })
	return hitPart == nil or (hitPosition - cameraPosition).Magnitude >= distance
end

-- Get closest part to cursor from multiple parts
local function getClosestPart(entity)
	local character = entity:IsA("Player") and entity.Character or entity
	if not character then
		return nil
	end
	if not SilentAimConfig.MultipleParts.Enabled then
		return character:FindFirstChild(SilentAimConfig.AimPart)
	end
	local shortestDistance = Inf
	local closestPart = nil
	local mousePosition = UserInputService:GetMouseLocation()
	
	for _, partName in ipairs(SilentAimConfig.MultipleParts.Parts) do
		local part = character:FindFirstChild(partName)
		if part and part:IsA("BasePart") then
			local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
			if onScreen then
				local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
				if distance < shortestDistance then
					closestPart = part
					shortestDistance = distance
				end
			end
		end
	end
	return closestPart or character:FindFirstChild(SilentAimConfig.AimPart)
end

-- Get closest entity (player or bot) to cursor
local function getClosestEntityToCursor()
	local shortestDistance = Inf
	local closestEntity = nil
	local mousePosition = UserInputService:GetMouseLocation()
	
	-- Check players
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character and isEntityAlive(player) and wallCheck(player) then
			-- Add KO and Grabbed checks
			if (SilentAimConfig.Checks.KOCheck or SilentAimConfig.Checks.GrabbedCheck) and player:IsA("Player") then
				local bodyEffects = player.Character:FindFirstChild("BodyEffects")
				if bodyEffects then
					-- Skip knocked out targets if KO check is enabled
					if SilentAimConfig.Checks.KOCheck and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value then
						continue
					end
					
					-- Skip grabbed targets if Grabbed check is enabled
					if SilentAimConfig.Checks.GrabbedCheck and player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
						continue
					end
				end
			end
	
			local part = player.Character:FindFirstChild(SilentAimConfig.AimPart)
			if part then
				local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
					if distance < shortestDistance then
						closestEntity = player
						shortestDistance = distance
					end
				end
			end
		end
	end

	-- Check bots
	for _, bot in ipairs(BotsFolder:GetChildren()) do
		if bot:IsA("Model") and isEntityAlive(bot) and wallCheck(bot) then
			local part = bot:FindFirstChild(SilentAimConfig.AimPart)
			if part then
				local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude
					if distance < shortestDistance then
						closestEntity = bot
						shortestDistance = distance
					end
				end
			end
		end
	end
	
	return closestEntity
end

-- Velmodded Resolver
local function velmoddedResolver(targetEntity)
	local character = targetEntity:IsA("Player") and targetEntity.Character or targetEntity
	if not character or not character:FindFirstChild(SilentAimConfig.AimPart) then
		return nil
	end
	
	local aimPart = character[SilentAimConfig.AimPart]
	local currentTime = tick()
	local deltaTime = currentTime - velmoddedState.last_refresh
	
	if deltaTime > SilentAimConfig.Prediction.Velmodded.ResolverRefresh / 1000 then
		if not velmoddedState.last_position then
			velmoddedState.last_position = aimPart.Position
		else
			velmoddedState.target_velocity = (aimPart.Position - velmoddedState.last_position) / deltaTime
			velmoddedState.last_position = aimPart.Position
		end
		velmoddedState.last_refresh = currentTime
	end
	
	return aimPart.Position + (velmoddedState.target_velocity * SilentAimConfig.Prediction.Velmodded.PredictionFactor)
end

-- Predict target position
local function getPredictedPosition(targetEntity)
	local character = targetEntity:IsA("Player") and targetEntity.Character or targetEntity
	if not character or not character:FindFirstChild(SilentAimConfig.AimPart) then
		return nil
	end
	
	local aimPartPos = character[SilentAimConfig.AimPart].Position
	
	if not SilentAimConfig.Prediction.Enabled then
		return aimPartPos
	end
	
	if SilentAimConfig.Prediction.Type == "Velmodded" then
		velmoddedState.target = targetEntity
		return velmoddedResolver(targetEntity)
	end
	
	if not lastPosition or not lastUpdateTime then
		lastPosition = aimPartPos
		lastUpdateTime = tick()
		predictedPosition = aimPartPos
		return predictedPosition
	end
	
	local currentTime = tick()
	local deltaTime = currentTime - lastUpdateTime
	local predictionType = SilentAimConfig.Prediction.Type
	
	if predictionType == "Vel" then
		local velocity = character[SilentAimConfig.AimPart].Velocity
		predictedPosition = aimPartPos + Vector3.new(
			velocity.X * SilentAimConfig.Prediction.PredictionXZ,
			velocity.Y * SilentAimConfig.Prediction.PredictionY,
			velocity.Z * SilentAimConfig.Prediction.PredictionXZ
		)
	elseif predictionType == "MoveDir" then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		predictedPosition = aimPartPos + (humanoid and humanoid.MoveDirection * (SilentAimConfig.Prediction.PredictionXZ * 10) or Vector3.zero)
	elseif predictionType == "CFrame" then
		if (aimPartPos - lastPosition).Magnitude < 0.001 then
			predictedPosition = aimPartPos
		else
			local distance = (aimPartPos - lastPosition).Magnitude
			local predictedDistance = (distance / deltaTime) * (0.1 * (SilentAimConfig.Prediction.PredictionXZ * 10))
			predictedPosition = aimPartPos + (aimPartPos - lastPosition).Unit * predictedDistance
			local yChange = (aimPartPos.Y - lastPosition.Y) / deltaTime * (0.1 * SilentAimConfig.Prediction.PredictionY)
			predictedPosition = predictedPosition + Vector3.new(0, yChange, 0)
		end
	end
	
	lastUpdateTime = currentTime
	lastPosition = aimPartPos
	return predictedPosition
end

-- Aiming logic with metatable hook
local function setupAimbot()
	local mt = getrawmetatable(game)
	local oldIndex = mt.__index
	setreadonly(mt, false)
	
	mt.__index = function(self, key)
		if not checkcaller() and self == LocalPlayer:GetMouse() and SilentAimConfig.Enabled and (key == "Hit" or key == "Target") then
			if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
				local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
				if character and isEntityAlive(selectedTarget) then
					if SilentAimConfig.Checks.TargetDeath and character:FindFirstChild("Humanoid").Health <= 0 then
						entityStates[selectedTarget].isTarget = false
						selectedTarget = nil
						velmoddedState.target = nil
						velmoddedState.last_position = nil
						velmoddedState.target_velocity = Vector3.zero
						return oldIndex(self, key)
					end
					
					local targetPart = getClosestPart(selectedTarget)
					if targetPart then
						local finalPosition = SilentAimConfig.Prediction.Enabled and getPredictedPosition(selectedTarget) or targetPart.Position
						if finalPosition then
							local humanoid = character:FindFirstChildOfClass("Humanoid")
							if humanoid then
								if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
									finalPosition = finalPosition + Vector3.new(0, SilentAimConfig.Offsets.Jump, 0)
								elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
									finalPosition = finalPosition + Vector3.new(0, SilentAimConfig.Offsets.Fall, 0)
								end
							end
							return key == "Hit" and CFrame.new(finalPosition) or targetPart
						end
					end
				end
			end
		end
		return oldIndex(self, key)
	end
	
	setreadonly(mt, true)
end

-- Функция для получения имени цели
local function getTargetName(entity)
    if entity:IsA("Player") then
        return entity.Name
    elseif entity:IsA("Model") then
        return entity.Name
    end
    return "Target"
end

-- Function to create highlight for current target
function createTargetHighlight()
    -- Remove any existing highlight
    if targetHighlight then
        targetHighlight:Destroy()
        targetHighlight = nil
    end
    
    -- Don't create highlight if feature is disabled or no target
    if not SilentAimConfig.TargetHighlight.Enabled or not selectedTarget then 
        return 
    end
    
    -- Get character model
    local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
    if not character then
        return
    end
    
    -- Create new highlight
    targetHighlight = Instance.new("Highlight")
    targetHighlight.Name = "TargetHighlight"
    targetHighlight.FillColor = SilentAimConfig.TargetHighlight.FillColor
    targetHighlight.OutlineColor = SilentAimConfig.TargetHighlight.OutlineColor
    targetHighlight.FillTransparency = 0.5 -- Fixed value
    targetHighlight.OutlineTransparency = 0 -- Fixed value
    targetHighlight.Adornee = character
    targetHighlight.Parent = game.CoreGui
end

-- Function to create tracer to current target using Drawing API
function createTargetTracer()
    -- Clean up existing tracer
    cleanupTracer()
    
    -- Don't create tracer if feature is disabled or no target
    if not SilentAimConfig.Tracer.Enabled or not selectedTarget then 
        return 
    end
    
    -- Create Drawing line object
    tracerLine = Drawing.new("Line")
    tracerLine.Visible = false -- Will be set to true in update function when positions are valid
    tracerLine.Color = SilentAimConfig.Tracer.Color
    tracerLine.Thickness = SilentAimConfig.Tracer.Thickness
    tracerLine.Transparency = 1 -- Fully opaque
    
    -- Tracer will be updated in the update loop
end

-- Function to update tracer position (from mouse to target)
function updateTracerPosition()
    if not tracerLine or not SilentAimConfig.Tracer.Enabled or not selectedTarget then
        return
    end
    
    local targetCharacter = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
    if not targetCharacter then
        tracerLine.Visible = false
        return
    end
    
    local targetPart = targetCharacter:FindFirstChild(SilentAimConfig.AimPart)
    if not targetPart then
        tracerLine.Visible = false
        return
    end
    
    -- Get target position in world space
    local targetPosition = targetPart.Position
    
    -- Convert target position to screen space
    local targetScreenPosition, targetOnScreen = Camera:WorldToViewportPoint(targetPosition)
    
    -- Get mouse position
    local mousePosition = UserInputService:GetMouseLocation()
    
    -- Update line points
    tracerLine.From = Vector2.new(mousePosition.X, mousePosition.Y)
    tracerLine.To = Vector2.new(targetScreenPosition.X, targetScreenPosition.Y)
    
    -- Only show if target is on screen
    tracerLine.Visible = targetOnScreen
end

-- Function to clean up tracer
function cleanupTracer()
    if tracerLine then
        tracerLine:Remove()
        tracerLine = nil
    end
end

-- Handle keybind for target selection
local function setupKeybind()
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		local keyCode = SilentAimConfig.Keybind
		if typeof(keyCode) == "string" then
			keyCode = Enum.KeyCode[keyCode]
		end
		
		if input.KeyCode == keyCode then
			if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
				-- Deselect current target
				entityStates[selectedTarget].isTarget = false
				local targetName = getTargetName(selectedTarget)
				
				-- Clean up highlight and tracer
				if targetHighlight then
                    targetHighlight:Destroy()
                    targetHighlight = nil
				end
				
				cleanupTracer()
				
				selectedTarget = nil
				velmoddedState.target = nil
				velmoddedState.last_position = nil
				velmoddedState.target_velocity = Vector3.zero
				
				Library:Notify("Aimbot unlocked", 1.5)
			else
				-- Select new target
				local closestEntity = getClosestEntityToCursor()
				if closestEntity then
					-- Clean up previous target highlight and tracer
					if targetHighlight then
                        targetHighlight:Destroy()
                        targetHighlight = nil
					end
					
					cleanupTracer()
					
					selectedTarget = closestEntity
					entityStates[selectedTarget].isTarget = true
					local targetName = getTargetName(selectedTarget)
					
					if SilentAimConfig.Prediction.Type == "Velmodded" then
						velmoddedState.target = selectedTarget
					end
					
					-- Create highlight and tracer for new target
					createTargetHighlight()
					createTargetTracer()
					
					Library:Notify("Aimbot locked to " .. targetName, 1.5)
				else
					Library:Notify("No target found", 1.5)
				end
			end
		end
	end)
end

-- Fix tools on character spawn/respawn
local function fixTool(character)
	if character then
		for _, tool in ipairs(character:GetChildren()) do
			if tool:IsA("Tool") then
				tool.Parent = LocalPlayer:FindFirstChildOfClass("Backpack")
				break
			end
		end
	end
end

-- Handle character spawn/respawn
local function setupCharacterHandling()
	fixTool(LocalPlayer.Character)
	LocalPlayer.CharacterAdded:Connect(function(character)
		fixTool(character)
		if selectedTarget and SilentAimConfig.Checks.ResetTargetOnLocalDeath then
			entityStates[selectedTarget].isTarget = false
			selectedTarget = nil
			velmoddedState.target = nil
			velmoddedState.last_position = nil
			velmoddedState.target_velocity = Vector3.zero
		end
		
		-- Отключаем AutoRotate, если LookAt включен
		if SilentAimConfig.LookAt.Enabled then
		    local humanoid = character:WaitForChild("Humanoid", 1)
		    if humanoid then
		        humanoid.AutoRotate = false
		    end
		end
	end)
end

-- BulletTP functions
local BulletTP = {
    Connection = nil,
    LastTool = nil,
    ToolConnections = {}
}

-- Функция для расчета смещения Grip
local function calculateGripOffset(origin, target)
    local actualOrigin = origin * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
    return actualOrigin:ToObjectSpace(target):inverse()
end

-- Функция телепортации пули
local function teleportBullet(tool)
    if not SilentAimConfig.BulletTP.Enabled or not tool or not LocalPlayer.Character then 
        return 
    end
    
    -- Используем только цель аимбота
    if not selectedTarget or not entityStates[selectedTarget] or not entityStates[selectedTarget].isTarget then
        -- Если цель не выбрана, ничего не делаем
        return
    end
    
    local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
    if not character then return end
    
    -- Используем тот же AimPart, что и в аимботе
    local targetPart = character:FindFirstChild(SilentAimConfig.AimPart)
    if not targetPart then return end
    
    -- Получаем позицию с учетом предсказания из аимбота
    local targetPosition
    if SilentAimConfig.Prediction.Enabled then
        targetPosition = getPredictedPosition(selectedTarget)
    else
        targetPosition = targetPart.Position
    end
    
    if not targetPosition then return end
    
    -- Добавляем смещения для прыжка/падения
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Jump, 0)
        elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Fall, 0)
        end
    end
    
    local targetCFrame = CFrame.new(targetPosition)
    
    -- Меняем Grip оружия для телепортации пули
    local originPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("RightHand")
    if originPart then
        local originalGrip = tool.Grip
        
        tool.Parent = LocalPlayer.Backpack
        tool.Grip = calculateGripOffset(originPart.CFrame, targetCFrame)
        tool.Parent = LocalPlayer.Character
        RunService.RenderStepped:Wait()
        tool.Parent = LocalPlayer.Backpack
        tool.Grip = originalGrip
        tool.Parent = LocalPlayer.Character
    end
end

-- Настройка BulletTP через переопределение метатаблицы
local function setupBulletTPMetatable()
    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)
    
    -- Переопределяем метатаблицу для перехвата Mouse.Hit/Mouse.Target
    mt.__index = newcclosure(function(self, key)
        -- Проверяем оригинальное поведение аимбота
        local result = oldIndex(self, key)
        
        -- Добавляем логику BulletTP
        if not checkcaller() and self == LocalPlayer:GetMouse() and SilentAimConfig.BulletTP.Enabled and (key == "Hit" or key == "Target") then
            if selectedTarget and entityStates[selectedTarget] and entityStates[selectedTarget].isTarget then
                local character = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
                if character then
                    local targetPart = character:FindFirstChild(SilentAimConfig.AimPart)
                    if targetPart then
                        -- Используем то же предсказание, что и в аимботе
                        local targetPosition = SilentAimConfig.Prediction.Enabled and getPredictedPosition(selectedTarget) or targetPart.Position
                        
                        if targetPosition then
                            -- Добавляем смещения для прыжка/падения
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            if humanoid then
                                if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                                    targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Jump, 0)
                                elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                                    targetPosition = targetPosition + Vector3.new(0, SilentAimConfig.Offsets.Fall, 0)
                                end
                            end
                            
                            if key == "Hit" then
                                return CFrame.new(targetPosition)
                            elseif key == "Target" then
                                return targetPart
                            end
                        end
                    end
                end
            end
        end
        
        return result
    end)
    
    setreadonly(mt, true)
end

-- Обработка инструментов для BulletTP
local function handleTool(tool)
    if not tool:IsA("Tool") then return end
    
    -- Отключаем все существующие соединения с Grip
    for _, conn in pairs(getconnections(tool:GetPropertyChangedSignal("Grip"))) do
        conn:Disable()
    end
    
    -- Отключаем старые соединения для этого инструмента
    if BulletTP.ToolConnections[tool] then
        BulletTP.ToolConnections[tool]:Disconnect()
        BulletTP.ToolConnections[tool] = nil
    end
    
    -- Создаем новое соединение на активацию (выстрел)
    BulletTP.ToolConnections[tool] = tool.Activated:Connect(function()
        if SilentAimConfig.BulletTP.Enabled then
            teleportBullet(tool)
        end
    end)
end

-- Настройка BulletTP для персонажа
local function setupBulletTPCharacter(character)
    if not character then return end
    
    -- Обрабатываем текущие инструменты
    for _, child in pairs(character:GetChildren()) do
        if child:IsA("Tool") then
            handleTool(child)
        end
    end
    
    -- Подключаемся к добавлению новых инструментов
    local connection = character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            handleTool(child)
        end
    end)
    
    -- Сохраняем соединение для последующей очистки
    if BulletTP.Connection then
        BulletTP.Connection:Disconnect()
    end
    BulletTP.Connection = connection
    
    -- Подключаемся к удалению инструментов
    character.ChildRemoved:Connect(function(child)
        if child:IsA("Tool") and BulletTP.ToolConnections[child] then
            BulletTP.ToolConnections[child]:Disconnect()
            BulletTP.ToolConnections[child] = nil
        end
    end)
end

-- Инициализация BulletTP
local function setupBulletTP()
    -- Настраиваем метатаблицу
    setupBulletTPMetatable()
    
    -- Настраиваем обработку для текущего персонажа
    if LocalPlayer.Character then
        setupBulletTPCharacter(LocalPlayer.Character)
    end
    
    -- Подключаемся к появлению нового персонажа
    LocalPlayer.CharacterAdded:Connect(function(character)
        setupBulletTPCharacter(character)
    end)
    
    -- Очищаем соединения при удалении персонажа
    LocalPlayer.CharacterRemoving:Connect(function()
        if BulletTP.Connection then
            BulletTP.Connection:Disconnect()
            BulletTP.Connection = nil
        end
        
        for tool, conn in pairs(BulletTP.ToolConnections) do
            conn:Disconnect()
            BulletTP.ToolConnections[tool] = nil
        end
    end)
end

-- Add Target Strafe tab
local TargetStrafeGroup = CombatTab:AddRightGroupbox("Target Strafe")

-- Main toggle for Target Strafe
local TargetStrafeToggle = TargetStrafeGroup:AddToggle("TargetStrafeEnabled", {
    Text = "Enable",
    Default = TargetStrafeConfig.Enabled,
    Tooltip = "Orbit around your target",
    Callback = function(Value)
        TargetStrafeConfig.Enabled = Value
        
        -- Cleanup if disabling
        if not Value then
            -- Restore collisions
            disableNoClip()
        end
        
        Library:Notify("Target Strafe " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- Add keybind to toggle
local StrafeKey = TargetStrafeToggle:AddKeyPicker("StrafeKey", {
    Default = "Y",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Toggle Key",
    Callback = function(Value)
        TargetStrafeConfig.Enabled = Value
    end
})

-- Radius slider
local RadiusSlider = TargetStrafeGroup:AddSlider("StrafeRadius", {
    Text = "Radius",
    Default = TargetStrafeConfig.Radius,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Suffix = " studs",
    Callback = function(Value)
        TargetStrafeConfig.Radius = Value
    end
})

-- Speed slider
local SpeedSlider = TargetStrafeGroup:AddSlider("StrafeSpeed", {
    Text = "Speed",
    Default = TargetStrafeConfig.Speed,
    Min = 1,
    Max = 15,
    Rounding = 1,
    Suffix = " rad/s",
    Callback = function(Value)
        TargetStrafeConfig.Speed = Value
    end
})

-- Y-Offset slider
local YOffsetSlider = TargetStrafeGroup:AddSlider("StrafeYOffset", {
    Text = "Y-Offset",
    Default = TargetStrafeConfig.YOffset,
    Min = -10,
    Max = 10,
    Rounding = 1,
    Suffix = " studs",
    Callback = function(Value)
        TargetStrafeConfig.YOffset = Value
    end
})

-- Avoid walls toggle
local AvoidWallsToggle = TargetStrafeGroup:AddToggle("AvoidWallsEnabled", {
    Text = "Avoid Walls",
    Default = TargetStrafeConfig.AvoidWalls,
    Tooltip = "Disable collisions while strafing",
    Callback = function(Value)
        TargetStrafeConfig.AvoidWalls = Value
    end
})

-- Smoothing slider
local LerpSpeedSlider = TargetStrafeGroup:AddSlider("LerpSpeed", {
    Text = "Smoothness",
    Default = TargetStrafeConfig.LerpSpeed * 10, -- Масштабируем для UI
    Min = 1,
    Max = 10,
    Rounding = 1,
    Suffix = "",
    Callback = function(Value)
        TargetStrafeConfig.LerpSpeed = Value / 10 -- Преобразуем обратно для работы
    end
})

-- Улучшенная функция NoClip для обхода всех объектов
local function enableNoClip()
    if TargetStrafeConfig.State.NoClipConnection then
        TargetStrafeConfig.State.NoClipConnection:Disconnect()
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    -- Сохраняем оригинальные значения CanCollide для частей персонажа
    TargetStrafeConfig.State.OriginalCollision = {}
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            TargetStrafeConfig.State.OriginalCollision[part] = {
                CanCollide = part.CanCollide,
                CanTouch = part.CanTouch,
                CanQuery = part.CanQuery
            }
            part.CanCollide = false
            part.CanTouch = false
            part.CanQuery = false
        end
    end
    
    -- Создаем соединение для постоянного отключения коллизии во время обновления
    TargetStrafeConfig.State.NoClipConnection = RunService.Stepped:Connect(function()
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

-- Восстановление коллизии
local function disableNoClip()
    if TargetStrafeConfig.State.NoClipConnection then
        TargetStrafeConfig.State.NoClipConnection:Disconnect()
        TargetStrafeConfig.State.NoClipConnection = nil
    end
    
    if TargetStrafeConfig.State.OriginalCollision then
        for part, props in pairs(TargetStrafeConfig.State.OriginalCollision) do
            if part and part.Parent then
                part.CanCollide = props.CanCollide
                part.CanTouch = props.CanTouch
                if props.CanQuery ~= nil then
                    part.CanQuery = props.CanQuery
                end
            end
        end
        TargetStrafeConfig.State.OriginalCollision = nil
    end
end

-- Изменение функции disableCollisions на использование новой функции NoClip
local function disableCollisions()
    if not TargetStrafeConfig.AvoidWalls then return end
    enableNoClip()
end

-- Function to initialize BodyPosition for TargetStrafe
local function initBodyPosition()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    if not TargetStrafeConfig.State.BodyPosition then
        TargetStrafeConfig.State.BodyPosition = Instance.new("BodyPosition")
        TargetStrafeConfig.State.BodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        TargetStrafeConfig.State.BodyPosition.P = 10000 -- Жесткость
        TargetStrafeConfig.State.BodyPosition.D = 1000 -- Демпфирование
        TargetStrafeConfig.State.BodyPosition.Parent = humanoidRootPart
    end
end

-- Target strafe update function
local function updateTargetStrafe(deltaTime)
    -- Check if strafe is enabled and we have a target
    if not TargetStrafeConfig.Enabled or not selectedTarget or not entityStates[selectedTarget] or not entityStates[selectedTarget].isTarget then
        -- Cleanup if needed
        if TargetStrafeConfig.AvoidWalls and TargetStrafeConfig.State.NoClipConnection then
            disableNoClip()
        end
        return
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Get target character
    local targetCharacter = selectedTarget:IsA("Player") and selectedTarget.Character or selectedTarget
    if not targetCharacter then return end
    
    local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    
    -- Make sure we have collision disabled if needed
    if TargetStrafeConfig.AvoidWalls and not TargetStrafeConfig.State.NoClipConnection then
        disableCollisions()
    end
    
    -- Update angle based on speed
    TargetStrafeConfig.State.Angle = TargetStrafeConfig.State.Angle + (TargetStrafeConfig.Speed * deltaTime)
    
    -- Calculate new position
    local targetPos = targetRoot.Position
    local offset = Vector3.new(
        math.cos(TargetStrafeConfig.State.Angle) * TargetStrafeConfig.Radius, 
        TargetStrafeConfig.YOffset, 
        math.sin(TargetStrafeConfig.State.Angle) * TargetStrafeConfig.Radius
    )
    local newPos = targetPos + offset
    
    -- Используем CFrame движение
    humanoidRootPart.CFrame = CFrame.new(newPos, Vector3.new(targetPos.X, newPos.Y, targetPos.Z))
end

-- AutoFire и AutoReload конфигурация
local GunFeaturesConfig = {
    AutoReload = {
        Enabled = false
    },
    Connections = {}
}

-- Добавляем группу для функций оружия
local GunFeaturesGroup = CombatTab:AddLeftGroupbox("Gun Features")

-- AutoReload toggle
local AutoReloadToggle = GunFeaturesGroup:AddToggle("AutoReloadEnabled", {
    Text = "Auto Reload",
    Default = false,
    Tooltip = "Автоматически перезаряжает оружие когда кончаются патроны",
    Callback = function(Value)
        GunFeaturesConfig.AutoReload.Enabled = Value
        
        -- Если оружие уже экипировано, начинаем отслеживать
        local character = LocalPlayer.Character
        if character and Value then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool then
                trackWeapon(tool)
            end
        end
        
        Library:Notify("Auto Reload " .. (Value and "enabled" or "disabled"), 1.5)
    end
})

-- Функции для AutoFire и AutoReload
-- Функция для уменьшения задержек
local function reduceCooldowns(tool)
    if tool and getconnections then
        for _, connection in ipairs(getconnections(tool.Activated)) do
            local func = connection.Function
            if func then
                local funcInfo = debug.getinfo(func)
                for i = 1, funcInfo.nups do
                    local c, n = debug.getupvalue(func, i)
                    if type(c) == "number" then
                        debug.setupvalue(func, i, 0.01)
                    end
                end
            end
        end
    end
end

-- Функция имитации клика по центру экрана
local function simulateMouseClick()
    local screenSize = Camera.ViewportSize
    local centerX, centerY = screenSize.X / 2, screenSize.Y / 2
    local VirtualUser = game:GetService("VirtualUser")
    VirtualUser:ClickButton1(Vector2.new(centerX, centerY))
end

-- Функция активации инструмента
local function activateTool()
    local tool = GunFeaturesConfig.AutoFire.CurrentTool
    if tool and tool.Parent == LocalPlayer.Character then
        reduceCooldowns(tool)
        if tool.Activate then
            tool:Activate()
        end
    end
end

-- Функция отслеживания оружия (перезарядка)
function trackWeapon(tool)
    if not tool or not tool:IsA("Tool") then return end
    
    local ammoValue = tool:FindFirstChild("Ammo")
    if not ammoValue or not ammoValue:IsA("IntValue") then return end
    
    -- Очищаем предыдущие соединения
    if GunFeaturesConfig.Connections[tool] then
        for _, conn in pairs(GunFeaturesConfig.Connections[tool]) do
            conn:Disconnect()
        end
    end
    
    GunFeaturesConfig.Connections[tool] = {}
    
    -- Отслеживаем изменение патронов
    local ammoConnection = ammoValue.Changed:Connect(function(newAmmo)
        if GunFeaturesConfig.AutoReload.Enabled and newAmmo <= 0 then
            -- Вызываем перезарядку
            ReplicatedStorage.MainEvent:FireServer("Reload", tool.Name)
        end
    end)
    
    -- Отслеживаем снятие оружия
    local unequipConnection = tool.Unequipped:Connect(function()
        if GunFeaturesConfig.Connections[tool] then
            for _, conn in pairs(GunFeaturesConfig.Connections[tool]) do
                conn:Disconnect()
            end
            GunFeaturesConfig.Connections[tool] = nil
        end
    end)
    
    GunFeaturesConfig.Connections[tool] = {
        ammo = ammoConnection,
        unequip = unequipConnection
    }
end

-- Обработчики событий для оружия
local function setupGunFeatureEvents()
    -- Отслеживание экипировки оружия
    LocalPlayer.Character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            if GunFeaturesConfig.AutoReload.Enabled then
                trackWeapon(child)
            end
        end
    end)
    
    -- Отслеживание нового персонажа (респавн)
    LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        -- Проверяем, есть ли уже экипированное оружие после респавна
        task.spawn(function()
            task.wait(0.5) -- Даем время на экипировку оружия после респавна
            local equippedTool = newCharacter:FindFirstChildOfClass("Tool")
            
            if equippedTool and GunFeaturesConfig.AutoReload.Enabled then
                trackWeapon(equippedTool)
            end
        end)
    end)
    
    -- Проверка существующих инструментов
    for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA("Tool") then
            tool.Equipped:Connect(function()
                if GunFeaturesConfig.AutoReload.Enabled then
                    trackWeapon(tool)
                end
            end)
        end
    end
    
    -- Отслеживание новых инструментов
    LocalPlayer.Backpack.ChildAdded:Connect(function(tool)
        if tool:IsA("Tool") then
            tool.Equipped:Connect(function()
                if GunFeaturesConfig.AutoReload.Enabled then
                    trackWeapon(tool)
                end
            end)
        end
    end)
end

-- Gun Features code...

-- ================== COMBAT END ==================

-- ================== MOVEMENT START ==================

-- Speed Hack Settings
local SpeedHackGroup = MovementTab:AddLeftGroupbox("Speed Hack")

-- Конфигурация Speed Hack
local SpeedHackConfig = {
    Enabled = false,
    Speed = 50,
    Keybind = "V"
}

-- Speed Hack Logic
local speedHackConnection
local function updateSpeedHack(character)
    if not character then return end
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local humanoid = character:WaitForChild("Humanoid")
    local moveDirection = Vector3.new(0, 0, 0)

    if speedHackConnection then
        speedHackConnection:Disconnect()
    end

    speedHackConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if SpeedHackConfig.Enabled then
            local move = humanoid.MoveDirection
            if move.Magnitude > 0 then
                moveDirection = move.Unit * SpeedHackConfig.Speed
                rootPart.CFrame = rootPart.CFrame + (moveDirection * deltaTime)
            end
        end
    end)
end

-- Speed Hack UI Elements
local SpeedHackToggle = SpeedHackGroup:AddToggle("SpeedHackEnabled", {
    Text = "Enable Speed Hack",
    Default = SpeedHackConfig.Enabled,
    Tooltip = "Enable/Disable CFrame Speed Hack",
    Callback = function(Value)
        SpeedHackConfig.Enabled = Value
        if Value then
            updateSpeedHack(LocalPlayer.Character)
        elseif speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
    end
})

local SpeedHackKeybind = SpeedHackToggle:AddKeyPicker("SpeedHackKeybind", {
    Default = SpeedHackConfig.Keybind,
    Mode = "Toggle",
    Text = "Speed Hack Key",
    NoUI = false,
    Callback = function(Value)
        SpeedHackConfig.Enabled = not SpeedHackConfig.Enabled
        SpeedHackToggle:SetValue(SpeedHackConfig.Enabled)
        Library:Notify("Speed Hack " .. (SpeedHackConfig.Enabled and "включен" or "выключен"), 2)
        if SpeedHackConfig.Enabled then
            updateSpeedHack(LocalPlayer.Character)
        elseif speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
    end,
    ChangedCallback = function(NewKey)
        SpeedHackConfig.Keybind = tostring(NewKey):lower()
    end
})

SpeedHackGroup:AddInput("SpeedHackSpeed", {
    Default = tostring(SpeedHackConfig.Speed),
    Numeric = true,
    Finished = true,
    Text = "Speed Value",
    Tooltip = "Set the speed value (studs per second)",
    Placeholder = "Enter speed...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 0 then
            SpeedHackConfig.Speed = numValue
            Library:Notify("Speed set to " .. numValue, 2)
        else
            Library:Notify("Please enter a valid number!", 2)
        end
    end
})

-- Fly Functionality
local FlyGroup = MovementTab:AddRightGroupbox("Fly")

-- Конфигурация полета
local FlyConfig = {
    Enabled = false,
    Speed = 1,
    Keybind = "F"
}

-- Переменные для полета
local FlyLoop = nil

-- Функция активации полета
local function toggleFly(state)
    FlyConfig.Enabled = state
    
    -- Отключаем предыдущий цикл полета, если есть
    if FlyLoop then
        FlyLoop:Disconnect()
        FlyLoop = nil
    end
    
    if state then
        -- Включаем полет
        FlyLoop = RunService.Stepped:Connect(function()
            local character = LocalPlayer.Character
            if not character then return end
            
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChild("Humanoid")
            if not humanoidRootPart or not humanoid then return end
            
            local speed = FlyConfig.Speed * 50
            local velocity = Vector3.new(0, 1.2, 0)
            
            -- Определяем направление движения
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                velocity = velocity + (Camera.CoordinateFrame.lookVector * speed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                velocity = velocity + (Camera.CoordinateFrame.rightVector * -speed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                velocity = velocity + (Camera.CoordinateFrame.lookVector * -speed)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                velocity = velocity + (Camera.CoordinateFrame.rightVector * speed)
            end
            
            -- Применяем скорость и состояние полета
            humanoidRootPart.Velocity = velocity
            humanoid:ChangeState("Freefall")
        end)
        
        Library:Notify("fly on", 2)
    else
        -- Выключаем полет
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid:ChangeState("Landing")
        end
        
        Library:Notify("fly off", 2)
    end
end

-- Добавляем переключатель полета
local FlyToggle = FlyGroup:AddToggle("FlyEnabled", {
    Text = "toggle fly",
    Default = FlyConfig.Enabled,
    Tooltip = "makes you fly",
    Callback = function(Value)
        toggleFly(Value)
    end
})

-- Добавляем привязку клавиши
local FlyKeybind = FlyToggle:AddKeyPicker("FlyKeybind", {
    Default = FlyConfig.Keybind,
    Text = "Fly",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(Value)
        -- Синхронизируем с состоянием переключателя
        FlyToggle:SetValue(Value)
    end
})

-- Добавляем слайдер для скорости полета
local FlySpeedSlider = FlyGroup:AddSlider("FlySpeed", {
    Text = "FlySpeed",
    Default = FlyConfig.Speed,
    Min = 0.5,
    Max = 20,
    Rounding = 1,
    Suffix = "x",
    Callback = function(Value)
        FlyConfig.Speed = Value
    end
})

-- Handle character respawn for SpeedHack
LocalPlayer.CharacterAdded:Connect(function(character)
    if SpeedHackConfig.Enabled then
        updateSpeedHack(character)
    end
end)

-- ================== MOVEMENT END ==================

-- Initialize aimbot
initEntityStates()
setupAimbot()
setupKeybind()
setupCharacterHandling()
setupBulletTP()
setupGunFeatureEvents() -- Инициализируем обработчики для функций оружия

-- Connect functions to RunService
local autoStompConnection = RunService.Heartbeat:Connect(applyDesyncStomp)
local targetLookConnection = RunService.RenderStepped:Connect(lookAtTarget)

-- Update tracer position every frame
RunService.RenderStepped:Connect(function()
    -- Update tracer if enabled with selected target
    if SilentAimConfig.Tracer.Enabled and selectedTarget then
        updateTracerPosition()
    end
end)

-- Add target strafe to RunService
local targetStrafeConnection = RunService.Heartbeat:Connect(function(deltaTime)
    updateTargetStrafe(deltaTime)
end)

-- Clean up when script is stopped
game:BindToClose(function()
    if autoStompConnection then
        autoStompConnection:Disconnect()
    end
    
    if targetLookConnection then
        targetLookConnection:Disconnect()
    end
    
    if targetStrafeConnection then
        targetStrafeConnection:Disconnect()
    end
    
    if BulletTP.Connection then
        BulletTP.Connection:Disconnect()
    end
    
    for tool, conn in pairs(BulletTP.ToolConnections) do
        conn:Disconnect()
    end
    
    cleanupDesync()
    
    if GripPosLoop then
        GripPosLoop:Disconnect()
    end
    
    if RandomGripLoop then
        RandomGripLoop:Disconnect()
    end
    
    -- Clean up highlight and tracer
    if targetHighlight then
        targetHighlight:Destroy()
        targetHighlight = nil
    end
    
    cleanupTracer()
    
    -- Cleanup target strafe
    if TargetStrafeConfig.State.BodyPosition then
        TargetStrafeConfig.State.BodyPosition:Destroy()
    end
    
    if TargetStrafeConfig.State.NoClipConnection then
        TargetStrafeConfig.State.NoClipConnection:Disconnect()
    end
    
    if TargetStrafeConfig.State.OriginalCollision then
        for part, props in pairs(TargetStrafeConfig.State.OriginalCollision) do
            if part and part.Parent then
                part.CanCollide = props.CanCollide
                part.CanTouch = props.CanTouch
                if props.CanQuery ~= nil then
                    part.CanQuery = props.CanQuery
                end
            end
        end
    end
    
    -- Удаляем очистку AntiGround
    
    -- Очистка SpeedHack
    if speedHackConnection then
        speedHackConnection:Disconnect()
        speedHackConnection = nil
    end
    
    -- Очистка FlyLoop
    if FlyLoop then
        FlyLoop:Disconnect()
        FlyLoop = nil
    end
end)

-- Show the UI
Library:Toggle(true)
